// This file is automatically generated by Cargo.
// It is not intended for manual editing.
// To generate, please run `cargo build -p topiary`
const languages: {[index: string]: any} = {
  "bash": {
    query: `; Configuration
(#language! bash)

; NOTE There is (currently) no support for line continuations. As such,
; any which are encountered by Topiary will be forcibly collapsed on to
; a single line. (See Issue #172)

; Don't modify string literals, heredocs, comments, atomic "words" or
; variable expansions (simple or otherwise)
; FIXME The first line of heredocs are affected by the indent level
[
  (comment)
  (expansion)
  (heredoc_body)
  (simple_expansion)
  (string)
  (word)
] @leaf

;; Spacing

; Allow blank line before
[
  (c_style_for_statement)
  (case_item)
  (case_statement)
  (command)
  (comment)
  (compound_statement)
  (declaration_command)
  (for_statement)
  (function_definition)
  (if_statement)
  (list)
  (pipeline)
  (redirected_statement)
  (subshell)
  (variable_assignment)
  (while_statement)
] @allow_blank_line_before

; Insert a new line before multi-line syntactic blocks, regardless of
; context
[
  (c_style_for_statement)
  (case_statement)
  (for_statement)
  (function_definition)
  (if_statement)
  (while_statement)
] @prepend_hardline

; Subshells and compound statements should have a new line inserted
; before them when they are top-level constructs. Beyond that level, the
; extra spacing makes the code overly sparse. (This is also a pragmatic
; choice: as we have to avoid the exception of function definitions, the
; list of complementary contexts we'd have to enumerate queries over is
; rather large!)
(program
  [
    (compound_statement)
    (subshell)
  ] @prepend_hardline
)

; A run of "units of execution" (see Commands section, below; sans
; variables which are special) should be interposed by a new line, after
; a multi-line syntactic block or variable.
(
  [
    (c_style_for_statement)
    (case_statement)
    (declaration_command)
    (for_statement)
    (function_definition)
    (if_statement)
    (variable_assignment)
    (while_statement)
  ]
  .
  ; Commands (sans variables)
  [(command) (list) (pipeline) (subshell) (compound_statement) (redirected_statement)] @prepend_hardline
)

; A run of variable declarations and assignments should be interposed by
; a new line, after almost anything else. This makes them stand out.
(
  [
    (c_style_for_statement)
    (case_statement)
    (command)
    (compound_statement)
    (for_statement)
    (function_definition)
    (if_statement)
    (list)
    (pipeline)
    (redirected_statement)
    (subshell)
    (while_statement)
  ]
  .
  [
    (declaration_command)
    (variable_assignment)
  ] @prepend_hardline
)

; Append a space to the following keywords and delimiters
[
  ";"
  "case"
  "declare"
  "do"
  "elif"
  "export"
  "for"
  "if"
  "in"
  "local"
  "readonly"
  "select"
  "then"
  "typeset"
  "until"
  "while"
] @append_space

; Prepend a space to intra-statement keywords
[
  "in"
] @prepend_space

;; Comments

; Comments come in two flavours: standalone (i.e., it's the only thing
; on a line, starting at the current indent level); and trailing (i.e.,
; following some other statement on the same line, with a space
; interposed). Bash does not have multi-line comments; they are all
; single-line.
;
; The grammar parses all comments as the (comment) node, which are
; siblings under a common parent.
;
; Formatting Rules:
;
; 1. A comment's contents must not be touched; some (namely the shebang)
;    have a syntactic purpose.
; 2. All comments must end with a new line.
; 3. Comments can be interposed by blank lines, if they exist in the
;    input (i.e., blank lines shouldn't be engineered elsewhere).
; 4. A comment can never change flavour (i.e., standalone to trailing,
;    or vice versa).
; 5. Trailing comments should be interposed by a space.

; Rule 1: See @leaf rule, above

; Rule 2
(comment) @append_hardline

; Rule 3: See @allow_blank_line_before rule, above.
; FIXME This doesn't quite get us what we want. It's close, but blank
; lines between comments can get consumed.

; Rule 4: We only have to protect against the case of a standalone
; comment, after a statement, being slurped on to that statement's line
; and becoming a trailing comment. That case is satisfied by Rule 5.

; Rule 5
(
  (comment) @prepend_space
  .
  "\\n"
)

;; Compound Statements and Subshells

; Compound statements and subshells are formatted in exactly the same
; way. In a multi-line context, their opening parenthesis triggers a new
; line and the start of an indent block; the closing parenthesis
; finishes that block. In a single-line context, spacing is used instead
; of new lines (NOTE that this is a syntactic requirement of compound
; statements, but not of subshells).
;
; NOTE Despite being isomorphic, the queries for compound statements and
; subshells are _not_ generalised, to ensure parentheses balance.

(compound_statement
  .
  "{" @append_spaced_softline @append_indent_start
  _
  "}" @prepend_spaced_softline @prepend_indent_end
  .
)

(subshell
  .
  "(" @append_spaced_softline @append_indent_start
  _
  ")" @prepend_spaced_softline @prepend_indent_end
  .
)

;; Commands

; "Command" is an epithet for, broadly speaking, a "unit of execution".
; It is such a pervasive and general concept in Bash that we need to
; take care when considering the context. For example, the condition in
; an if statement or while loop is a command, but we don't want to
; insert a new line in these cases.
;
; In terms of the grammar, the following nodes should be considered
; "commands":
;
; * (command)
;   Simple commands (e.g., binaries, builtins, functions, etc.)
;
; * (list)
;   Command lists (i.e., "commands" sequenced by && and ||)
;
; * (pipeline)
;   Command pipelines (i.e., "commands" sequenced by | and |&)
;
; * (subshell)
;   Subshells (i.e., arbitrary code enclosed within parentheses)
;
; * (compound_statement)
;   Compound statements (i.e., arbitrary code enclosed within
;   curly-parentheses)
;
; * (redirected_statement)
;   IO redirection (NOTE These aren't semantically "units of execution"
;   in their own right, but are treated as such due to how the grammar
;   organises them as parent nodes of such units)
;
; * (variable_assignment)
;   Variable assignment (NOTE These aren't "units of execution" at all,
;   but are treated as such to isolate them from their declaration
;   context; see Variables section, below)

; We care about the line spacing of "commands" that appear in any of the
; following contexts:
;
; * Top-level statements
; * Multi-line compound statements and subshells
; * Any branch of a conditional or case statement
; * Loop bodies
; * Multi-line command substitutions
;
; We address each context individually, as there's no way to isolate the
; exceptional contexts, where no line spacing is required. When a
; "command" is followed by a new line in the input, then the grammar
; inserts an anonymous "\\n" sibling node. We target these to achieve the
; formatting we want.
;
; FIXME Adding @delete to the \\n anonymous nodes removes the errant
; trailing space. However, doing so breaks inter-block spacing and
; (weirdly) de-indentation at the end of a non-terminated case branch.

(program
  [(command) (list) (pipeline) (subshell) (compound_statement) (redirected_statement) (variable_assignment)] @append_hardline
  .
  "\\n"
)

(compound_statement
  [(command) (list) (pipeline) (compound_statement) (subshell) (redirected_statement) (variable_assignment)] @append_hardline
  .
  "\\n"
)

(subshell
  [(command) (list) (pipeline) (compound_statement) (subshell) (redirected_statement) (variable_assignment)] @append_hardline
  .
  "\\n"
)

(if_statement
  .
  _
  "then"
  [(command) (list) (pipeline) (compound_statement) (subshell) (redirected_statement) (variable_assignment)] @append_hardline
  .
  "\\n"
)

(elif_clause
  .
  _
  "then"
  [(command) (list) (pipeline) (compound_statement) (subshell) (redirected_statement) (variable_assignment)] @append_hardline
  .
  "\\n"
)

(else_clause
  .
  "else"
  [(command) (list) (pipeline) (compound_statement) (subshell) (redirected_statement) (variable_assignment)] @append_hardline
  .
  "\\n"
)

(case_item
  .
  _
  ")"
  [(command) (list) (pipeline) (compound_statement) (subshell) (redirected_statement) (variable_assignment)] @append_hardline
  .
  "\\n"
)

(do_group
  .
  "do"
  [(command) (list) (pipeline) (compound_statement) (subshell) (redirected_statement) (variable_assignment)] @append_hardline
  .
  "\\n"
)

(command_substitution
  [(command) (list) (pipeline) (compound_statement) (subshell) (redirected_statement) (variable_assignment)] @append_hardline
  .
  "\\n"
)

; Spaces between named nodes and command list/pipeline delimiters
(list
  [(_) "&&" "||"] @append_space
  .
  _
)

(pipeline
  [(_) "|" "|&"] @append_space
  .
  _
)

; Prepend the asynchronous operator with a space
; NOTE If I'm not mistaken, this can interpose two "commands" -- like a
; delimiter -- but I've never seen this form in the wild
(_
  [(command) (list) (pipeline) (compound_statement) (subshell) (redirected_statement)]
  .
  "&" @prepend_space
)

; Spaces between command and its arguments
; NOTE If we treat (command) as a leaf node, then commands are formatted
; as is and the below will be ignored. On balance, I think keeping this
; rule, rather than deferring to the input, is the better choice
; (although it's not without its problems; e.g., see Issue #172).
(command
  (_) @append_space
  .
  (_)
)

; Ensure the negation operator is surrounded by spaces
; NOTE This is a syntactic requirement
(negated_command
  .
  "!" @prepend_space @append_space
)

; Multi-line command substitutions become an indent block
; NOTE This is a bit of a hack! We _have_ to append softlines,
; otherwise command substitutions enclosed within a string will force
; that new line to the start of the string, which can result in
; syntactically incorrect output (see Issue 201). Thus we target the
; node immediately before the closing parenthesis.
; FIXME If there is only a single named child within a multi-line
; command substitution, then -- for reasons -- the new line will not be
; appended after the $(. The output remains syntactically correct.
(command_substitution
  .
  "$(" @append_empty_softline @append_indent_start
  _
  (_) @append_empty_softline @append_indent_end
  .
  ")"
  .
)

;; Redirections

; Spaces between command and any redirections (NOTE this will not insert
; a space between the redirection operator and its destination)
(redirected_statement
  (_) @append_space
  .
  (_)
)

; ...with the exceptions of herestrings, that are spaced
(herestring_redirect (_) @prepend_space)

; Ensure heredocs start on a new line, after their start marker, and
; there is a new line after their end marker, when followed by any named
; node. (NOTE This may still need refinement...)
; NOTE These are a syntactic requirements
(heredoc_start) @append_hardline

; NOTE Anecdotally, queries that target the (heredoc_body) node act
; differently, dependant upon expansions existing in the heredoc. Hence
; this query, that prepends a new line to any following named node,
; rather than simply appending a new line to any heredoc (which,
; unexpectedly, doesn't work in the general sense).
(
  (heredoc_body)
  .
  (_) @prepend_hardline
)

;; Conditionals

; New line after conditionals
[
  (if_statement)
  (elif_clause)
  (else_clause)
] @append_hardline

; New line after "then" and start indent block
[
  (if_statement)
  (elif_clause)
]
"then" @append_hardline @append_indent_start

; New line after "else" and start indent block
(else_clause
  .
  "else" @append_hardline @append_indent_start
)

; Finish indent block at "fi", "else" or "elif"
(if_statement
  [
    "fi"
    (else_clause)
    (elif_clause)
  ] @prepend_indent_end @prepend_hardline
)

; Keep the "if"/"elif" and the "then" on the same line,
; inserting a spaced delimiter when necessary
; FIXME Why does the space need to be explicitly inserted?
(_
  ";"* @do_nothing
  .
  "then" @prepend_delimiter @prepend_space
  (#delimiter! ";")
)

;; Test Commands

(test_command
  .
  (unary_expression
    _ @prepend_space
  ) @append_space
)

; FIXME The binary_expression node is not being returned by Tree-Sitter
; in the context of a (test_command); it does work in other contexts
; See https://github.com/tweag/topiary/pull/155#issuecomment-1364143677
(binary_expression
  left: _ @append_space
  right: _ @prepend_space
)

;; Case Statements

; Indentation block between the "in" and the "esac"
(case_statement
  .
  "case"
  .
  _
  .
  "in" @append_hardline @append_indent_start
  _
  "esac" @prepend_hardline @prepend_indent_end
  .
) @append_hardline

; New (soft)line after branch, which starts an indentation block up
; until its end
(case_item
  ")" @append_spaced_softline @append_indent_start
) @append_indent_end

; Ensure case branch terminators appear on their own line, in a
; multi-line context; or, at least, push the next case branch on to a
; new line in a single-line context
; NOTE The terminator is optional in the final condition, which is why
; we deal with closing the indent block above
(case_item
  [
    ";;"
    ";;&"
    ";&"
  ] @append_hardline
  .
)

;; Loops

; Indentation block between the "do" and the "done"
(do_group
  .
  "do" @append_hardline @append_indent_start
  _
  "done" @prepend_hardline @prepend_indent_end
  .
) @append_hardline

; Ensure the word list is delimited by spaces in classic for loops
(for_statement
  value: _* @prepend_space
)

; Surround the loop condition with spaces in C-style for loops
(c_style_for_statement
  initializer: _ @prepend_space
  update: _ @append_space
)

; Keep the loop construct and the "do" on the same line,
; inserting a spaced delimiter when necessary
; FIXME Why does the space need to be explicitly inserted?
(_
  ";"* @do_nothing
  .
  (do_group) @prepend_delimiter @prepend_space
  (#delimiter! ";")
)

;; Function Definitions

; NOTE Much of the formatting work for function definitions is done by
; whatever already-defined queries apply to the function body (e.g.,
; (compound_statement), etc.). All we do here is ensure functions get
; a space between its name and body, a new line afterwards and deleting
; the redundant "function" keyword, if it exists in the input.

; NOTE Technically speaking, a function body can be _any_ compound. For
; example, this is valid Bash:
;
;   my_function() for x in $@; do echo $x; done
;
; However, this form is never seen in the wild and the Tree Sitter Bash
; grammar won't even parse it. It only accepts subshells, compound
; statements and test commands as function bodies.

(function_definition
  body: _ @prepend_space @append_hardline
)

(function_definition
  .
  "function" @delete
)

;; Variable Declaration, Assignment and Expansion

; NOTE It would be nice to convert (simple_expansion) nodes into
; (expansion) nodes by inserting "delimiters" in appropriate places.
; This doesn't appear to currently be possible (see Issue #187).

; NOTE Assignment only gets a new line when not part of a declaration;
; that is, all the contexts in which units of execution can appear.
; Hence the queries for this are defined above. (My kingdom for a
; negative anchor!)

; Declarations always end with a new line
(declaration_command) @append_hardline

; Multiple variables can be exported (and assigned) at once
(declaration_command
  .
  "export"
  [(variable_name) (variable_assignment)] @prepend_space
)

; Environment variables assigned to commands inline need to be spaced
(command
  (variable_assignment) @append_space
)
`,
    input: `#!/usr/bin/env bash

# Here is a comment
do_a_thing
produce | consume # here's a comment
something

# comment
a=123 # comment

# a different comment
# that spans multiple lines
if some_command
then
do_something
another_thing --foo    --bar
else
do_something_else
fi


if [[ -e "/some/file" ]]|| true; then
  foo
elif !((1==0))
then
  bar
  baz
else
    baz \\
  && quux || xyzzy&
fi

multi \\
| line |& pipeline

for thing in foo bar quux
do
  echo $thing
  rm -rf /
done

select thing in foo bar quux; do
  echo $thing
  break
done

for (( i=0; i<10; i++ )); do
  echo $i
done

while true
do
  echo "Hello world!"
done

until true
do
  echo "Hello world!"
done

case "\${foo}" in
  single) line --mode ;;
  multi)
    line && mode
    ;;&
  bar|quux)
    xyzzy
  do_something | least_expected
    ;;
  *)
    exit 1
esac

{
  here
  is
  { a; nested; compound; }
}

if { foo; }; then
  echo
fi

(
  here
  is
  ( a; nested; subshell )
)

if ( foo; bar ); then
  echo
fi

{ one; (inside; the); other; }
( one
  { inside
    the
  }
  other
)

function foo  () {
  local x=1
  x=2
  bar
  quux || xyzzy
}

quux() { xyzzy; }

export a b=1 c
declare x=$foo
x=123
echo "\${x:-something}"
echo "\${x/foo/bar}"
ENV_VAR=123 ANOTHER=456 some_command

cat <<-HEREDOC
	Here is
	a
	  heredoc
	HEREDOC

some_command > output < input
another_thing <<< herestring

if foo 2>/dev/null; then
  exit 1
fi

# This cannot be fixed without upstream changes; see Issue #200.
# {
#   cat <<EOF
# This shouldn't be indented \${foo}
# ...nor this
# EOF
# }

readonly a="$(foo | bar || baz --quux 2>&1)"
foo <(bar||baz --something) | tee >(quux)

export xyzzy=$(
  something
  another_thing --foo
)
`,
  },
  "json": {
    query: `; Configuration
(#language! json)

; Sometimes we want to indicate that certain parts of our source text should
; not be formatted, but taken as is. We use the leaf capture name to inform the
; tool of this.
(string) @leaf

; Append space after colons
":" @append_space

; We want every object and array to have the { start a softline and an indented
; block. So we match on the named object/array followed by the first anonymous
; node { or [.

; We do not want to add spaces or newlines in empty objects and arrays,
; so we add the newline and the indentation block only if there is a pair in
; the object (or a value in the array).
(object
  .
  "{" @append_spaced_softline @append_indent_start
  (pair)
  "}" @prepend_spaced_softline @prepend_indent_end
  .
)

(array
  .
  "[" @append_spaced_softline @append_indent_start
  (_value)
  "]" @prepend_spaced_softline @prepend_indent_end
  .
)

; Pairs should always end with a softline.
; Pairs come in two kinds, ones with a trailing comma, and those without.
; Those without are the last pair of an object,
; and the line is already added by the closing curly brace of the object.
(object
  "," @append_spaced_softline
)

; Items in an array must have a softline after. See also the pairs above.
(array
  "," @append_spaced_softline
)
`,
    input: `{
    "questions": [
        {
            "category": "sports",
            "id": 0,
            "question": "Which one is correct team name in the Eredivisie?",
            "options": ["Amsterdam United" , "FC Leiden" , "Troy" , "Nijmegen Eendracht Combinatie"],
            "answer": "Nijmegen Eendracht Combinatie"
        },
        {
            "category": "computing science",
            "id": 1,
            "question": "What is the type of the function \\"f = uncurry . const\\"?",
            "options": [
                "f :: (b -> c) -> (a, b) -> c",
                "f :: (a -> b1 -> c) -> b2 -> (a, b1) -> c"
            ],
            "answer": "f :: (b -> c) -> (a, b) -> c"
        },
        {
            "category": "computing science",
            "id": 2,
            "question": "What is the title of Turing's 1936 paper that is often considered the birth of modern computing science?",
            "options": [
                "An Unsolvable Problem of Elementary Number Theory",
                "Computing Machinery and Intelligence",
                "On computable numbers, with an application to the Entscheidungsproblem",
                "Finite automata and their decision problems"
            ],
            "answer": "On computable numbers, with an application to the Entscheidungsproblem"
        },
    {
      "category": {},
      "id": 3,
      "question": {"field":"None"},
      "options": [],
      "answer": null
    }

    ]
}
`,
  },
  "nickel": {
    query: `; Configuration
(#language! nickel)

;; General Spacing

; The following nodes in our source text should not be formatted
[
  (static_string)
  (str_chunks_single)
  (str_chunks_multi)
  (builtin)
] @leaf

; Allow a blank line before the following nodes
[
  (comment)
  (record_field)
  (record_last_field)
] @allow_blank_line_before

; Allow blank lines to appear between a let bind and its result
(let_expr
  (let_in_block)
  .
  (term) @allow_blank_line_before
)

; Surround with spaces: keywords, operators, annotation markers
(
  [
    "if"
    "then"
    "else"
    "forall"
    "in"
    "let"
    "match"
    "null"
    "true"
    "false"
    "fun"
    "import"
    "default"
    "doc"
    "force"
    "optional"
    "priority"
    "|"
    ":"
    "?"
    "="
    "rec"
    "Array"
    "Dyn"
    "Num"
    "Bool"
    "Str"
    "->"
    "=>"
    ; Infix operators
    "++"
    "@"
    "*"
    "/"
    "%"
    "+"
    "-"
    "!"
    "&"
    "|>"
    "<"
    "<="
    ">"
    ">="
    "=="
    "!="
    "&&"
    "||"
  ] @prepend_space @append_space
)

; Don't insert spaces before the following delimiters
; NOTE This will destroy the space in a polymorphic record tail. For
; example: forall. { x: Number; a } -> {; a}
; WARNING We don't include "." as it is very common for it to appear in
; string interpolation, for record field access, which will manifest the
; bug documented in Issue #395. The remaining delimiters in this
; alternation can also appear in such contexts, but they're much less
; likely; i.e., this is a trade-off, to avoid over-complicating the
; formatting rules.
[
  ","
  ";"
] @prepend_antispace

; Don't insert spaces immediately inside parentheses. In a multi-line
; context, start an indentation block
; WARNING Using parentheses in string interpolation will manifest the
; bug documented in Issue #395
(atom
  .
  "(" @append_empty_softline @append_indent_start @append_antispace
  ")" @prepend_antispace @prepend_indent_end @prepend_empty_softline
  .
)

; Don't insert spaces between infix operators and their operand
(infix_expr
  .
  [
    "-"
    (infix_u_op_5 "!")
  ] @append_antispace
  .
  (infix_expr)
  .
)

; Flow a chain of infix expressions over new lines, in a multi-line
; context. Note that we _don't_ want this to happen for comparison
; operators, which fall under nodes (infix_b_op_7) and (infix_b_op_8).
(uni_term
  (#scope_id! "infix_chain")
  (infix_expr) @begin_scope
) @end_scope

(infix_expr
  (#scope_id! "infix_chain")
  (infix_expr)
  .
  [
    (infix_b_op_2) ; ++ and @
    (infix_b_op_3) ; *, / and %
    (infix_b_op_4) ; + and -
    (infix_b_op_6) ; & and |>
    (infix_lazy_b_op_9) ; &&
    (infix_lazy_b_op_10) ; ||
  ] @prepend_spaced_scoped_softline
  .
  (infix_expr)
)

; Surround all polymorphic type variables with spaces
(forall
  (ident) @prepend_space
)

;; Comments

(comment) @prepend_input_softline @append_hardline

;; Bound Expressions
; i.e., Let expressions and record fields

; The default, multi-line behaviour for the RHS of a bound expression is
; for it to start an indentation block on a new line. However, the
; following idiomatic exceptions should not behave in this way:
;
; * Record literals                   { ... }
; * Array literals                    [ ... ]
; * Enum literals                     [| ... |]
; * Parentheticals                    ( ... )
; * Function declarations             fun ... => ...
; * Match statements                  match { ... }
; * Multi-line and symbolic strings   m%"..."% / xxx-s%"..."%
;
; These should remain in-line.

(_
  (#scope_id! "bound_rhs")
  "=" @begin_scope
  .
  (term) @end_scope
)

(_
  (#scope_id! "bound_rhs")
  "=" @append_spaced_scoped_softline @append_indent_start
  .
  (term
    .
    (uni_term
      .
      [
        ; There is scope for factoring these patterns with
        ; embedded alternations. Keeping them separate is probably more
        ; efficient to process and certainly easier to read.

        ; Record literals
        (infix_expr . (applicative . (record_operand . (atom . (uni_record)))))

        ; Array literals
        (infix_expr . (applicative . (record_operand . (atom . "["))))

        ; Enum literals
        (infix_expr . (applicative . (record_operand . (atom . (type_atom . "[|")))))

        ; Parentheticals
        (infix_expr . (applicative . (record_operand . (atom . "("))))

        ; Function declarations
        (fun_expr)

        ; Match statements
        (infix_expr . (applicative . (match_expr)))

        ; Multi-line and symbolic strings
        (infix_expr . (applicative . (record_operand . (atom . (str_chunks)))))
      ]? @do_nothing
    )
  ) @append_indent_end
)

; If the RHS starts with a comment, which itself is followed by a hard
; line, then we apply the normal indent block formatting in a multi-line
; context (i.e., no exceptions)
(_
  "=" @append_indent_start
  .
  (comment)
  (term) @append_indent_end
)

; A let expression looks like:
;
;   let [rec] IDENT = EXPR in EXPR
;
; The formatting for the bound expression is handled by the above rules,
; which also apply to record field values. The "in" should appear on a
; new line, if the entire let expression is multi-line. The result
; expression (i.e., after the "in") should appear on an new line, if
; that is multi-line. We don't start an indentation block for the result
; expression, to avoid long diagonals in a series of let expressions
; (which is idiomatic).

(let_expr
  (#scope_id! "let_result")
  (let_in_block
    "in" @begin_scope @prepend_spaced_softline
  )
  (term) @end_scope
)

(let_expr
  (#scope_id! "let_result")
  (term) @prepend_spaced_scoped_softline
)

;; Annotations

; We want the equals sign to be aligned with the annotations, if they
; coexist, so create a scope that covers them both.
(
  (#scope_id! "annotated_assignment")
  (annot) @begin_scope
  .
  "=" @end_scope
)

; Start an indentation block from the start of the annotations to the
; end of the enclosing node
(_
  (annot) @prepend_indent_start
) @append_indent_end

; Put each annotation -- and the equals sign, if it follows annotations
; -- on a new line, in a multi-line context.
(annot
  (annot_atom) @prepend_spaced_softline
)

(
  (#scope_id! "annotated_assignment")
  "=" @prepend_spaced_scoped_softline
)

; Break a multi-line polymorphic type annotation after the type
; variables, starting an indentation block
(forall
  "." @append_spaced_softline @append_indent_start
) @append_indent_end

;; Functions

; Start a function's definition on a new line, in a multi-line context.
; This also defines an indentation block.
(fun_expr
  (#scope_id! "function_definition")
  "=>" @begin_scope @append_indent_start
) @append_indent_end @end_scope

(fun_expr
  (#scope_id! "function_definition")
  (term) @prepend_spaced_scoped_softline
)

(fun_expr
  (pattern) @append_space
)

; The applicative operator is a space, but in a multi-line context, we'd
; like the operands to start on their own line, each indented.
(infix_expr
  (#scope_id! "applicative_chain")
  (applicative) @begin_scope
) @end_scope

(
  (#scope_id! "applicative_chain")
  (applicative
    (applicative) @append_spaced_scoped_softline
    (comment)? @do_nothing
  )
)

; NOTE Unlike infix chains, applicatives bind to the left. So rather
; than creating a single indent block for all operands, we have to
; create one for each operand independently.
(applicative
  (applicative) @append_indent_start
) @append_indent_end

;; Conditionals

; Flow multi-line match cases into an indented block after the =>
(match_case
  "=>" @append_spaced_softline @append_indent_start
) @append_indent_end

; if...then...else expressions can either be single or multi-line. In a
; multi-line context, they will be formatted like so:
;
;   if CONDITION then
;     TRUE_TERM
;   else
;     FALSE_TERM
;
; NOTE If the FALSE_TERM is another if...then...else expression, in a
; multi-line context, then the indentation block is "cancelled" to
; create the illusion of an "else if" term:
;
;   if CONDITION1 then
;     TRUE_TERM1
;   else if CONDITION2 then
;     TRUE_TERM2
;   else
;     FALSE_TERM2
;
; This style has precedent from the manually formatted stdlib. (An
; alternative style is to give the "then" token its own line.)
(ite_expr
  "then" @append_spaced_softline @append_indent_start
  "else" @prepend_indent_end @prepend_spaced_softline
)

(ite_expr
  "else" @append_spaced_softline @append_indent_start
  t2: (term
    ; Don't apply formatting if an "else" is followed by an "if"
    (uni_term (ite_expr))? @do_nothing
  ) @append_indent_end
)

;; Container Types
; i.e., Arrays, records (and dictionaries, vicariously) and enums

; We don't want to add spaces/new lines in empty records, so the
; following query only matches if a named node exists within the record
; NOTE This rule also applies to (match) and (destruct) patterns
(_
  (#scope_id! "container")
  .
  "{" @append_spaced_softline @append_indent_start @begin_scope
  (_)
  "}" @prepend_indent_end @prepend_spaced_softline @end_scope
  .
)

; Unlike records, arrays should never have internal spacing, similar to
; parentheticals. (This is a conscious choice by the Nickel team; see
; Issue #407.)
(_
  (#scope_id! "container")
  .
  "[" @append_empty_softline @append_indent_start @begin_scope
  (_)
  "]" @prepend_indent_end @prepend_empty_softline @end_scope
  .
)

; It doesn't really make sense for an enum to
; have no members, so we ignore that case
(_
  (#scope_id! "container")
  .
  "[|" @append_spaced_softline @append_indent_start @begin_scope
  "|]" @prepend_indent_end @prepend_spaced_softline @end_scope
  .
)

(
  (#scope_id! "container")
  [
    ","
    ";"
  ] @append_spaced_scoped_softline
  .
  (comment)? @do_nothing
)
`,
    input: `{
  regression_tests = [
    # Interpolated record operation chains
    {
      # This is fine
      good = "%{interpolated}",

      # An interpolated (record_operation_chain) breaks the spacing
      bad = "%{interpolated.string}"
    },

    # Blank lines between a let bind and its result
    let x = 1 in
    let y = 2 in

    [x, y],

    # Trailing comments
    {
      a = # In bound expression
        123,

      b =
        if something then
          foo # After the truthy clause
        else
          bar,

      c = [
        foo, # After items in a compound value
        bar
      ],

      d =
        fn
          arg # After function arguments
          arg
    },

    # Container containing a comment
    [
      1,
      2,
      # Comment
      3
    ]
  ],

  # Nickel standard library as of af0d5ee

  array = {
    NonEmpty
      | doc m%"
        Contract to ensure the given array is not empty.

        For example:
        \`\`\`nickel
          ([] | NonEmpty) =>
            error
          ([ 1 ] | NonEmpty) =>
            [ 1 ]
        \`\`\`
        "%
      = fun label value =>
        if %typeof% value == \`Array then
          if %length% value != 0 then
            value
          else
            %blame% (%label_with_message% "empty array" label)
        else
          %blame% (%label_with_message% "not a array" label),

    first
      : forall a. Array a -> a
      | doc m%"
        Results in the first element of the given array.

        # Examples

        \`\`\`nickel
          first [ "this is the head", "this is not" ] =>
            "this is the head"
        \`\`\`
        "%
      = fun array => %elem_at% array 0,

    last
      : forall a. Array a -> a
      | doc m%"
        Results in the last element of the given array.

        # Examples

        \`\`\`nickel
          last [ "this is the head", "this is not" ] =>
            "this is not"
        \`\`\`
        "%
      = fun array => %elem_at% array (%length% array - 1),

    drop_first
      : forall a. Array a -> Array a
      | doc m%"
        Results in the given array without the first element.

        For example:
        \`\`\`nickel
          drop_first [ 1, 2, 3 ] =>
            [ 2, 3 ]
        \`\`\`
        "%
      = fun array => %array_slice% 1 (%length% array) array,

    drop_last
      : forall a. Array a -> Array a
      | doc m%"
        Results in the given array without the last element.

        For example:
        \`\`\`nickel
          drop_last [ 1, 2, 3 ] =>
            [ 1, 2 ]
        \`\`\`
        "%
      = fun array => %array_slice% 0 (%length% array - 1) array,

    length
      : forall a. Array a -> Number
      | doc m%"
        Results in a number representing the length of the given array.

        For example:
        \`\`\`nickel
          length [ "Hello,", " World!" ] =>
            2
        \`\`\`
        "%
      = fun l => %length% l,

    map
      : forall a b. (a -> b) -> Array a -> Array b
      | doc m%"
        \`map f [x1, x2, ..., xn]\` applies function \`f\` to every element in the array,
        resulting in \`[f x1, f x2, ... f xn]\`

        For example:
        \`\`\`nickel
          map (fun x => x + 1) [ 1, 2, 3 ] =>
            [ 2, 3, 4 ]
        \`\`\`
        "%
      = fun f l => %map% l f,

    at
      : forall a. Number -> Array a -> a
      | doc m%"
        Retrieves the n'th element from a array (0-indexed).

        For example:
        \`\`\`nickel
          at 3 [ "zero" "one" "two" "three" "four" ] =>
            "three"
        \`\`\`
        "%
      = fun n l => %elem_at% l n,

    concat
      : forall a. Array a -> Array a -> Array a
      | doc m%"
        Concatenates two arrays such that the second array is appended to the first.

        For example:
        \`\`\`nickel
          concat [ 1, 2, 3 ] [ 4, 5, 6 ] =>
            [ 1, 2, 3, 4, 5, 6 ]
        \`\`\`
        "%
      = fun l1 l2 => l1 @ l2,

    fold_left
      : forall a b. (a -> b -> a) -> a -> Array b -> a
      | doc m%"
        Fold a function over an array. Folds serve a similar purpose to loops or
        iterators in a functional language like Nickel. \`fold_left\` iterates over
        an array, by repeatedly applying a function over each element, threading
        an additional arbitrary state (the accumulator, of type \`a\` in the
        signature).

        \`fold_left f init [x1, x2, ..., xn]\` results in \`f (... (f (f init x1) x2) ...) xn\`.

        This function is strict in the intermediate accumulator.

        # Left vs right

        Folds come in two variants, left and right. How to decide which one to
        use?

        - If the folded function isn't associative (such as subtraction), then
          each variant will give a different result. The choice is dictacted by
          which one you need. For example:

          \`\`\`nickel
          array.fold_right (-) 0 [1, 2, 3, 4]
           => -2
          array.fold_left (-) 0 [1, 2, 3, 4]
           => -10
          \`\`\`
        - If the folded function is associative, both \`fold_right\` and
          \`fold_left\` return the same result. In that case, **\`fold_left\` is
          generally preferred**, because it forces the evaluation of the
          intermediate results resulting in less memory consumption and overall
          better performance (outside of pathological cases).
          \`fold_left\` also iterates from the start of the array, which
          correponds to the usual behavior of loops and iterators in most
          programming languages. There is one case where \`fold_right\` might be
          preferred, see the next point.
        - If the folded function is associative but _(left) short-circuiting_,
          meaning that it can sometimes determine the result without using the
          right argument, then \`fold_right\` provides early return. An example is
          the boolean AND operator \`&&\`: when evaluating \`left && right\`, if
          \`left\` is \`false\`, the whole expression will evaluate to \`false\`
          without even evaluating \`right\`. Consider the following expression:

          \`\`\`nickel
          array.replicate 1000 true
          # gives [false, .. true 1000 times]
          |> array.prepend false
          |> array.fold_right (&&) [false]
          \`\`\`

          Here, \`fold_right\` will stop at the first element, and the operation
          runs in constant time, given the definition of \`fold_right\` and the
          lazy evaluation of Nickel. If we had used \`fold_left\` instead, which
          is closer to a standard iterator, we would have iterated over all of
          the 1000 elements of the array.

        # Examples

        \`\`\`nickel
          fold_left (fun acc e => acc + e) 0 [ 1, 2, 3 ] =>
            (((0 + 1) + 2) 3) =>
            6
        \`\`\`
        "%
      = fun f acc l =>
        let length = %length% l in
        if length == 0 then
          acc
        else
          let rec go =
            fun acc n =>
              if n == length then
                acc
              else
                let next_acc = %elem_at% l n |> f acc in
                %seq% next_acc (go next_acc (n + 1))
          in
          go acc 0,

    fold_right
      : forall a b. (a -> b -> b) -> b -> Array a -> b
      | doc m%"
        Fold a function over an array. Folds serve a similar purpose to loops or
        iterators in a functional language like Nickel. \`fold_right\` iterates
        over an array, by repeatedly applying a function to each element and
        threading an additional arbitrary state (the accumulator of type \`a\` in
        the signature).

        \`fold_right f init [x1, x2, ..., xn]\` results in \`f x1 (f x2 (... (f xn init) ...))\`.

        # Left vs right

        Folds come in two variants, left and right. How to decide which one to
        use? Please refer to the documentation of \`fold_left\`.

        # Examples

        \`\`\`nickel
          fold_right (fun e acc => acc @ [e]) [] [ 1, 2, 3 ] =>
            ((([] @ [3]) @ [2]) @ [1]) =>
            [ 3, 2, 1 ]
        \`\`\`
        "%
      = fun f fst l =>
        let length = %length% l in
        let rec go =
          fun n =>
            if n == length then
              fst
            else
              go (n + 1)
              |> f (%elem_at% l n)
        in go 0,

    prepend
      : forall a. a -> Array a -> Array a
      | doc m%"
        Construct an array given the first element and the rest of the array.

        For example:
        \`\`\`nickel
          prepend 1 [ 2, 3 ] =>
            [ 1, 2, 3 ]
        \`\`\`
        "%
      = fun x l => [x] @ l,

    append
      : forall a. a -> Array a -> Array a
      | doc m%"
        Construct an array given the last element and the rest of the array.

        For example:
        \`\`\`nickel
          append 3 [ 1, 2 ] =>
            [ 1, 2, 3 ]
        \`\`\`
        "%
      = fun x l => l @ [x],

    reverse
      : forall a. Array a -> Array a
      | doc m%"
        Reverses the order of a array.

        For example:
        \`\`\`nickel
          reverse [ 1, 2, 3 ] =>
            [ 3, 2, 1 ]
        \`\`\`
        "%
      = fun l => fold_left (fun acc e => [e] @ acc) [] l,

    filter
      : forall a. (a -> Bool) -> Array a -> Array a
      | doc m%"
        \`filter f xs\` keeps all elements from \`xs\` given that satisfy \`f\`.

        For example:
        \`\`\`nickel
          filter (fun x => x <= 3) [ 4, 3, 2, 5, 1 ] =>
            [ 3, 2, 1 ]
        \`\`\`
        "%
      = fun pred l => fold_left (fun acc x => if pred x then acc @ [x] else acc) [] l,

    flatten
      : forall a. Array (Array a) -> Array a
      | doc m%"
        Flatten a array of arrays to a single array, essentially concatenating all arrays in the original array.

        For example:
        \`\`\`nickel
          flatten [[1, 2], [3, 4]] =>
            [1, 2, 3, 4]
        \`\`\`
        "%
      = fun l => fold_right (fun l acc => l @ acc) [] l,

    all
      : forall a. (a -> Bool) -> Array a -> Bool
      | doc m%"
        Results in true if all elements in the given array satisfy the predicate, false otherwise.

        For example:
        \`\`\`nickel
          all (fun x => x < 3) [ 1, 2 ] =>
            true
          all (fun x => x < 3) [ 1, 2 3 ] =>
            false
        \`\`\`
        "%
      = fun pred l => fold_right (fun x acc => if pred x then acc else false) true l,

    any
      : forall a. (a -> Bool) -> Array a -> Bool
      | doc m%"
        Results in false if no elements in the given array satisfy the predicate, true otherwise.

        For example:
        \`\`\`nickel
          any (fun x => x < 3) [ 1, 2, 3, 4 ] =>
            true
          any (fun x => x < 3) [ 5, 6, 7, 8 ] =>
            false
        \`\`\`
        "%
      = fun pred l => fold_right (fun x acc => if pred x then true else acc) false l,

    elem
      : forall a. a -> Array a -> Bool
      | doc m%"
        Results in true if the given element is a member of the array, false otherwise.

        For example:
        \`\`\`nickel
          elem 3 [ 1, 2, 3, 4, 5 ] =>
            true
        \`\`\`
        "%
      = fun elt => any (fun x => x == elt),

    partition
      : forall a. (a -> Bool) -> Array a -> { right : Array a, wrong : Array a }
      | doc m%"
        Partitions the given array in two new arrays: those containing the elements that satisfy the predicate, and those
        that do not.

        For example:
        \`\`\`nickel
          partition (fun x => x < 5) [ 2, 4, 5, 3, 7, 8, 6 ] =>
            { right = [ 3, 4, 2 ], wrong = [ 6, 8, 7, 5 ] }
        \`\`\`
        "%
      = fun pred l =>
        let aux =
          fun acc x =>
            if (pred x) then
              { right = acc.right @ [x], wrong = acc.wrong }
            else
              { right = acc.right, wrong = acc.wrong @ [x] }
        in
        fold_left aux { right = [], wrong = [] } l,

    generate
      : forall a. (Number -> a) -> Number -> Array a
      | doc m%"
        \`generate f n\` produces a array of length \`n\` by applying \`f\` on increasing numbers:
         \`[ f 0, f 1, ..., f (n - 1) ]\`.

        For example:
        \`\`\`nickel
          generate function.id 4 =>
            [ 0, 1, 2, 3 ]
        \`\`\`
        "%
      = fun f n => %generate% n f,

    sort
      | forall a. (a -> a -> [| \`Lesser, \`Equal, \`Greater |]) -> Array a -> Array a
      | doc m%"
        Sorts the given arrays based on the provided comparison operator.

        For example:
        \`\`\`nickel
          sort (fun x y => if x < y then \`Lesser else if (x == y) then \`Equal else \`Greater) [ 4, 5, 1, 2 ] =>
            [ 1, 2, 4, 5 ]
        \`\`\`
        "%
      #TODO: maybe inline partition to avoid contract checks?
      = fun cmp array =>
        let length = %length% array in
        let first = %elem_at% array 0 in
        let rest = %array_slice% 1 length array in
        let parts = partition (fun x => (cmp x first == \`Lesser)) rest in
        if length <= 1 then
          array
        else
          (sort cmp (parts.right)) @ [first] @ (sort cmp (parts.wrong)),

    flat_map
      : forall a b. (a -> Array b) -> Array a -> Array b
      | doc m%"
        First maps the given function over the array and then flattens the
        result.

        For example:
        \`\`\`nickel
        flat_map (fun x => [x, x]) [1, 2, 3]
          => [1, 1, 2, 2, 3, 3]
        \`\`\`
      "%
      = fun f xs => map f xs |> flatten,

    intersperse
      : forall a. a -> Array a -> Array a
      | doc m%"
        Intersperse the passed value between the elements of an array.

        For example:
        \`\`\`nickel
        intersperse ", " [ "Hello", "wonderful", "world!" ]
          => [ "Hello", ", ", "wonderful", ", ", "world!" ]
        intersperse ", " [ "Hello" ]
          => [ "Hello" ]
        intersperse ", " []
          => []
        \`\`\`
      "%
      = fun v array =>
        let length = %length% array in
        if length <= 1 then
          array
        else
          let first = %elem_at% array 0 in
          let rest = %array_slice% 1 length array in
          [first] @ (flat_map (fun a => [v, a]) rest),

    slice
      : forall a. Number -> Number -> Array a -> Array a
      | doc m%"
          \`slice start end array\` returns the slice of \`array\` between \`start\` (included) and
          \`end\` (excluded).

          # Preconditions

          In \`slice start end value\`, \`start\` and \`end\` must be positive
          integers such that \`0 <= start <= end <= array.length value\`.

          # Examples

          \`\`\`nickel
          slice 1 3 [ 0, 1, 2, 3, 4, 5]
            => [ 1, 2 ]
          slice 0 3 [ "Hello", "world", "!" ]
            => [ "Hello", "world", "!" ]
          slice 2 3 [ "Hello", "world", "!" ]
            => [ "!" ]
           \`\`\`
        "%
      = fun start end value => %array_slice% start end value,

    split_at
      : forall a. Number -> Array a -> { left : Array a, right : Array a }
      | doc m%"
          Splits an array in two at a given index, and puts all the elements
          to the left of the element at the given index (excluded) in the
          \`left\` field, and the rest of the array in the \`right\` field.

          # Preconditions

          In \`split_at inded value\`, \`index\` must be a positive integer such
          that \`0 <= index <= array.length value\`.

          # Examples

          \`\`\`nickel
          split_at 2 [ 0, 1, 2, 3, 4, 5]
            => { left = [ 2, 3, 4, 5 ], right = [ 0, 1 ] }
          split_at 0 [ "Hello", "world", "!" ]
            => { left = [  ], right = [ "Hello", "world", "!" ] }
          split_at 3 [ "Hello", "world", "!" ]
            => { left = [ "Hello", "world", "!" ], right = [  ] }
          \`\`\`
        "%
      = fun index value =>
        {
          left = %array_slice% 0 index value,
          right = %array_slice% index (%length% value) value
        },

    replicate
      : forall a. Number -> a -> Array a
      | doc m%"
          \`replicate n x\` creates an array containing \`x\` exactly \`n\` times.

          # Preconditions

          \`n\` must be an integer greater or equal to \`0\`.

          # Examples

          \`\`\`nickel
          replicate 0 false
            => [ ]
          replicate 5 "x"
            => [ "x", "x", "x", "x", "x" ]
          \`\`\`
        "%
      = fun n x => %generate% n (fun _i => x),

    range_step
      : Number -> Number -> Number -> Array Number
      | doc m%"
          \`range_step start end step\` generates the array of numbers
          \`[start, start + step, start + 2*step, ..]\` up to the first element
          (excluded) larger than or equal to \`end\`

          # Preconditions

          In \`range_step start end step\`, \`start\` and \`end\` must satisfy \`start
          <= end\`. \`step\` must be strictly greater than \`0\`.

          # Examples

          \`\`\`nickel
          range_step (-1.5) 2 0.5
           => [ -1.5, -1, -0.5, 0, 0.5, 1, 1.5 ]
          \`\`\`
        "%
      = fun start end step =>
        %generate% ((end - start) / step |> number.floor) (fun i => start + i * step),

    range
      : Number -> Number -> Array Number
      | doc m%"
          \`range start end\` generates the array of numbers
          \`[start, start + 1, start + 2, ..]\` up to the first element
          (excluded) larger than or equal to \`end\`.

          \`range start end\` is equivalent to \`range_step start end 1\`.

          # Preconditions

          In \`range_step start end\`, \`start\` and \`end\` must satisfy
          \`start <= end\`.

          # Examples

          \`\`\`nickel
          range 0 5
           => [ 0, 1, 2, 3, 4 ]
          \`\`\`
        "%
      = fun start end => range_step start end 1,

    reduce_left
      : forall a. (a -> a -> a) -> Array a -> a
      | doc m%"
        Reduces the elements to a single one, by repeatedly applying a reducing
        operation. If the array is empty, returns an empty array.

        \`reduce_left\` associates to the left, that is
        \`reduce_left op [x1, x2, ..., xn]\` results in \`op (... (op (op x1 x2) x3) ...) xn\`.

        \`reduce_left\` is the same as \`fold_left\`, but uses the first element as
        the initial accumulator.

        # Left vs right

        The rationale to decide between \`fold_left\` and \`fold_right\` applies to
        \`reduce_left\` and \`reduce_right\` as well. See the documentation of
        \`fold_left\`.

        # Examples

        \`\`\`nickel
          reduce_left (@) [ [1, 2], [3], [4,5] ]
            => (([1, 2] @ [3]) @ [4,5])
            => [ 1, 2, 4, 5 ]
          reduce_left (-) [ 1, 2, 3, 4]
            => ((1 - 2) - 3) - 4
            => -8
        \`\`\`
        "%
      = fun f array =>
        let first = %elem_at% array 0 in
        let rest = %array_slice% 1 (%length% array) array in
        fold_left f first rest,

    reduce_right
      : forall a. (a -> a -> a) -> Array a -> a
      | doc m%"
        Reduces the elements to a single one, by repeatedly applying a reducing
        operation. If the array is empty, returns an empty array.

        \`reduce_right\` associates to the right, that is
        \`reduce_right op [x1, x2, ..., xn]\` results in
        \`op x1 (op x2 (... (op xn-1 xn) ...))\`.

        \`reduce_right\` is the same as \`fold_right\`, but uses the last element as
        the initial element.

        # Left vs right

        The rationale to decide between \`fold_left\` and \`fold_right\` applies to
        \`reduce_left\` and \`reduce_right\` as well. See the documentation of
        \`fold_left\`.

        # Examples

        \`\`\`nickel
          reduce_right (@) [ [1, 2], [3], [4,5] ]
            => [1, 2] @ ([3] @ [4,5])
            => [ 1, 2, 4, 5 ]
          reduce_right (-) [ 1, 2, 3, 4]
            => 1 - (2 - (3 - 4))
            => -2
        \`\`\`
        "%
      = fun f array =>
        let last_index = %length% array - 1 in
        let last = %elem_at% array last_index in
        let rest = %array_slice% 0 last_index array in
        fold_right f last rest,
  },

  builtin = {
    is_number
      : Dyn -> Bool
      | doc m%"
      Checks if the given value is a number.

      For example:
      \`\`\`nickel
        is_number 1 =>
          true
        is_number "Hello, World!" =>
          false
      \`\`\`
      "%
      = fun x => %typeof% x == \`Number,

    is_bool
      : Dyn -> Bool
      | doc m%"
      Checks if the given value is a boolean.

      For example:
      \`\`\`nickel
        is_bool false =>
          true
        is_bool 42 =>
          false
      \`\`\`
      "%
      = fun x => %typeof% x == \`Bool,

    is_string
      : Dyn -> Bool
      | doc m%"
      Checks if the given value is a string.

      For example:
      \`\`\`nickel
        is_string true =>
          false
        is_string "Hello, World!" =>
          true
      \`\`\`
      "%
      = fun x => %typeof% x == \`String,

    is_enum
      : Dyn -> Bool
      | doc m%"
      Checks if the given value is an enum tag.

      For example:
      \`\`\`nickel
        is_enum true =>
          false
        is_enum \`false =>
          true
      \`\`\`
      "%
      = fun x => %typeof% x == \`Enum,

    is_function
      : Dyn -> Bool
      | doc m%"
      Checks if the given value is a function.

      For example
      \`\`\`nickel
        is_function (fun x => x) =>
          true
        is_function 42 =>
          false
      \`\`\`
      "%
      = fun x => %typeof% x == \`Function,

    is_array
      : Dyn -> Bool
      | doc m%"
      Checks if the given value is a array.

      For example
      \`\`\`nickel
        is_array [ 1, 2 ] =>
          true
        is_array 42 =>
          false
      \`\`\`
      "%
      = fun x => %typeof% x == \`Array,

    is_record
      : Dyn -> Bool
      | doc m%"
      Checks if the given value is a record.

      For example
      \`\`\`nickel
        is_record [ 1, 2 ] =>
          false
        is_record { hello = "Hello", world = "World" } =>
          true
      \`\`\`
      "%
      = fun x => %typeof% x == \`Record,

    typeof
      : Dyn -> [|
        \`Number,
        \`Bool,
        \`String,
        \`Enum,
        \`Label,
        \`Function,
        \`Array,
        \`Record,
        \`Other
      |]
      | doc m%"
      Results in a value representing the type of the typed value.

      For example:
      \`\`\`nickel
        typeof [ 1, 2 ] =>
          \`Array
        typeof (fun x => x) =>
          \`Function
      \`\`\`
      "%
      = fun x => %typeof% x,

    seq
      : forall a. Dyn -> a -> a
      | doc m%"
      \`seq x y\` forces the evaluation of \`x\`, before resulting in \`y\`.

      For example:
      \`\`\`nickel
        seq (42 / 0) 37 =>
          error
        seq (42 / 2) 37 =>
          37
        seq { tooFar = 42 / 0 } 37 =>
          37
      \`\`\`
      "%
      = fun x y => %seq% x y,

    deep_seq
      : forall a. Dyn -> a -> a
      | doc m%"
      \`deep_seq x y\` forces a deep evaluation \`x\`, before resulting in \`y\`.

      For example:
      \`\`\`nickel
        deep_seq (42 / 0) 37 =>
          error
        deep_seq (42 / 2) 37 =>
          37
        deep_seq { tooFar = 42 / 0 } 37 =>
          error
      \`\`\`
      "%
      = fun x y => %deep_seq% x y,

    hash
      : [| \`Md5, \`Sha1, \`Sha256, \`Sha512 |] -> String -> String
      | doc m%"
      Hashes the given string provided the desired hash algorithm.

      For example:
      \`\`\`nickel
        hash \`Md5 "hunter2" =>
          "2ab96390c7dbe3439de74d0c9b0b1767"
      \`\`\`
      "%
      = fun type s => %hash% type s,

    serialize
      : [| \`Json, \`Toml, \`Yaml |] -> Dyn -> String
      | doc m%"
      Serializes the given value to the desired representation.

      For example:
      \`\`\`nickel
        serialize \`Json { hello = "Hello", world = "World" } =>
          "{
            "hello": "Hello",
            "world": "World"
          }"
      \`\`\`
      "%
      = fun format x => %serialize% format (%force% x),

    deserialize
      : [| \`Json, \`Toml, \`Yaml |] -> String -> Dyn
      | doc m%"
      Deserializes the given string to a nickel value given the encoding of the string.

      For example:
      \`\`\`nickel
        deserialize \`Json "{ \\"hello\\": \\"Hello\\", \\"world\\": \\"World\\" }"
          { hello = "Hello", world = "World" }
      \`\`\`
      "%
      = fun format x => %deserialize% format x,

    to_string
      | string.Stringable -> String
      | doc m%"
      Converts a stringable value to a string representation. Same as
      \`string.from\`.

      For example:
      \`\`\`nickel
      from 42 =>
        "42"
      from \`Foo =>
        "Foo"
      from null =>
        "null"
      \`\`\`
      "%
      = fun x => %to_str% x,

    trace
      : forall a. String -> a -> a
      | doc m%"
      \`builtin.trace msg x\` prints \`msg\` to standard output when encountered by the evaluator,
      and proceed with the evaluation of \`x\`.

      For example:
      \`\`\`nickel
      builtin.trace "Hello, world!" true =>
        builtin.trace: Hello, world!
        true
      \`\`\`
      "%
      = fun msg x => %trace% msg x,

    FailWith
      | doc m%"
      A contract that always fails with a given message.

      For example:
      \`\`\`nickel
      1 | FailWith "message" =>
        error: contract broken by a value: message
          ┌─ :1:1
          │
        1 │ FailWith "message"
          │ ---------------------------- expected type
          │
          ┌─ repl-input-0:1:1
          │
        1 │ 1 | FailWith "message"
          │ ^ applied to this expression
      \`\`\`
    "%
      = fun msg label value => contract.blame_with_message msg label,

    fail_with
      | String -> Dyn
      | doc m%"
      Unconditionally abort evaluation with the given message.

      For example:
      \`\`\`nickel
      fail_with "message" =>
        error: contract broken by a value: message
      \`\`\`
    "%
      = fun msg => null | FailWith msg,
  },

  contract = {
    blame
      | doc m%"
        Raise blame for a given label.

        Type: \`forall a. Lbl -> a\`
        (for technical reasons, this function isn't actually statically typed)

        Blame is the mechanism to signal contract violiation in Nickel. It ends
        the program execution and print a detailed report thanks to the
        information tracked inside the label.

        For example:

        \`\`\`nickel
        IsZero = fun label value =>
          if value == 0 then
            value
          else
            contract.blame label
        \`\`\`
        "%
      = fun label => %blame% label,

    blame_with_message
      | doc m%"
        Raise blame with respect to a given label and a custom error message.

        Type: \`forall a. String -> Lbl -> a\`
        (for technical reasons, this function isn't actually statically typed)

        Same as \`blame\`, but take an additional custom error message that will be
        displayed as part of the blame error. \`blame_with_message message label\`
        is equivalent to \`blame (label.with_message message label)\`

        For example:

        \`\`\`nickel
        let IsZero = fun label value =>
          if value == 0 then
            value
          else
            contract.blame_with_message_message "Not zero" label
        in

        0 | IsZero
        \`\`\`
        "%
      = fun message label => %blame% (%label_with_message% message label),

    from_predicate
      | doc m%"
        Generate a contract from a boolean predicate.

        Type: \`(Dyn -> Bool) -> (Lbl -> Dyn -> Dyn)\`
        (for technical reasons, this function isn't actually statically typed)

        For example:

        \`\`\`nickel
        let IsZero = contract.from_predicate (fun x => x == 0) in
        0 | IsZero
        \`\`\`
        "%
      = fun pred label value => if pred value then value else %blame% label,

    label
      | doc m%"
          The label submodule, which gathers functions that manipulate the label
          of a contract.

          A label is a special opaque value automatically passed by the Nickel
          interpreter to contracts when performing a contract check.

          A label stores a stack of custom error diagnostics, that can be
          manipulated by the function of this module. Labels thus offer a way to
          customize the error message that will be shown if the contract is broken.

          The setters (\`with_XXX\` functions) always operate on the current error
          diagnostic, which is the last diagnotic on the stack (if the stack is
          empty, a fresh diagnostic is silently created when using a setter).
          The previous diagnostics are thus archived, and can't be modified
          anymore. All diagnostics will be shown during error reporting, with
          the most recent being used as the main one.

          \`contract.apply\` is the operation that pushes a new fresh diagnostic on
          the stack, saving the previously current error diagnostic. Indeed,
          \`contract.apply\` is mostly used to apply subcontracts inside a parent
          contract. Stacking the current diagnostic potentially customized by
          the parent contract saves the information inside, and provides a fresh
          diagnostic for the child contract to use.
        "%
      = {
        with_message
          | doc m%"
            Attach a custom error message to the current error diagnostic of a
            label.

            Type: \`String -> Lbl -> Lbl\`
            (for technical reasons, this function isn't actually statically typed)

            If a custom error message was previously set, there are two
            possibilities:
              - the label has gone through a \`contract.apply\` call in-between.
                In this case, the previous diagnostic has been stacked,
                and using \`with_message\` won't erase anything but rather modify
                the fresh current diagnostic.
              - no \`contract.apply\` has taken place since the last message was
                set. In this case, the current diagnostic is still the same, and
                the previous error message will be erased.

            For example:

            \`\`\`nickel
            let ContractNum = contract.from_predicate (fun x => x > 0 && x < 50) in

            let Contract = fun label value =>
              if builtin.is_number value then
                contract.apply
                  ContractNum
                  (contract.label.with_message
                    "num subcontract failed! (out of bound)"
                    label
                  )
                  value
              else
                value
            in

            5 | Contract
            \`\`\`
            "%
          = fun message label => %label_with_message% message label,

        with_notes
          | doc m%"
            Attach custom error notes to the current error diagnostic of a
            label.

            Type: \`Array String -> Lbl -> Lbl\`
            (for technical reasons, this function isn't actually statically typed)

            If custom error notes were previously set, there are two
            possibilities:
              - the label has gone through a \`contract.apply\` call in-between.
                In this case, the previous diagnostic has been stacked,
                and using \`with_notes\` won't erase anything but rather modify
                the fresh current diagnostic.
              - no \`contract.apply\` has taken place since the last message was
                set. In this case, the current diagnostic is still the same, and
                the previous error notes will be erased.

            For example:

            \`\`\`nickel
            let ContractNum = contract.from_predicate (fun x => x > 0 && x < 50) in

            let Contract = fun label value =>
              if builtin.is_number value then
                contract.apply
                  ContractNum
                  (label
                   |> contract.label.with_message "num subcontract failed! (out of bound)"
                   |> contract.label.with_notes [
                        "The value was a number, but this number is out of the expected bound",
                        "The value must be a number between 0 and 50, both excluded",
                      ]
                  )
                  value
              else
                value
            in

            5 | Contract
            \`\`\`
            "%
          # the %label_with_notes% operator expects an array of strings which is
          # fully evaluated, thus we force the notes first
          = fun notes label => %label_with_notes% (%force% notes) label,

        append_note
          | doc m%"
              Append a note to the notes of the current diagnostic of a label.

              Type: \`String -> Lbl -> Lbl\`
              (for technical reasons, this function isn't actually statically typed)
            "%
          = fun note label => %label_append_note% note label,
      },

    apply
      | doc m%"
          Apply a contract to a label and a value.

          Type: \`Contract -> Lbl -> Dyn -> Dyn\`
          (for technical reasons, this function isn't actually statically typed)

          Nickel supports user-defined contracts defined as functions, but also
          as records. Moreover, the interpreter performs additional book-keeping
          for error reporting when applying a contract in an expression
          \`value | Contract\`. You should not use standard function application
          to apply a contract, but this function instead.

          # Example

          \`\`\`nickel
          let Nullable = fun param_contract label value =>
            if value == null then null
            else contract.apply param_contract label value
          in
          let Contract = Nullable {foo | Number} in
          ({foo = 1} | Contract)
          \`\`\`

          # Diagnostic stack

          Using \`apply\` will stack the current custom reporting data, and create a
          fresh current working diagnostic. \`apply\` thus acts automatically as a
          split point between a contract and its subcontracts, providing the
          subcontracts with a fresh diagnostic to use, while remembering the
          previous diagnostics set by parent contracts.

          ## Illustration

          \`\`\`nickel
          let ChildContract = fun label value =>
            label
            |> contract.label.with_message "child's message"
            |> contract.label.append_note "child's note"
            |> contract.blame
          in

          let ParentContract = fun label value =>
            let label =
              label
              |> contract.label.with_message "parent's message"
              |> contract.label.append_note "parent's note"
            in
            contract.apply ChildContract label value
          in

          null | ParentContract
          \`\`\`

          This example will print two diagnostics: the main one, using the
          message and note of the child contract, and a secondary diagnostic,
          using the parent contract message and note.
        "%
      = fun contract label value =>
        %assume% contract (%label_push_diag% label) value,
  },

  enum = {
    Tag
      | doc m%"
          Contract to enforce the value is an enum tag.

          # Examples

          \`\`\`nickel
            (\`foo | Tag) =>
              \`foo
            (\`FooBar | Tag) =>
              \`FooBar
            ("tag" | Tag) =>
              error
          \`\`\`
          "%
      = contract.from_predicate builtin.is_enum,

    TagOrString
      | doc m%%"
            Accepts both enum tags and strings. Strings are automatically
            converted to an enum tag.

            \`TagOrString\` is typically used in conjunction with an enum type, to
            accept tags represented as strings (e.g. coming from a JSON
            serialization) as well.

            # Examples

            \`\`\` nickel
            let Schema = {
              protocol
                | enum.TagOrString
                | [| \`http, \`ftp |],
              port
                | Number,
              method
                | enum.TagOrString
                | [| \`GET, \`POST |]
            } in
            let serialized =
              m%"
                {"protocol": "http", "port": 80, "method": "GET"}
              "%
              |> builtin.deserialize \`Json
            in

            serialized | Schema
            \`\`\`
          "%%
      = fun label value =>
        %typeof% value
        |> match {
          \`String => %enum_from_str% value,
          \`Enum => value,
          _ =>
            contract.blame_with_message "expected either a string or an enum tag" label,
        },
  },

  function = {
    id
      : forall a. a -> a
      | doc m%"
    The identity function, that is
    \`\`\`nickel
    id x == x
    \`\`\`
    for any value \`x\`.
    "%
      = fun x => x,

    const
      : forall a b. a -> b -> a
      | doc m%"
    Results in the first argument.

    For example:
    \`\`\`nickel
    const 5 42 == 5
    \`\`\`
    "%
      = fun x y => x,

    compose
      : forall a b c. (b -> c) -> (a -> b) -> (a -> c)
      | doc m%"
    Function composition, right to left. That is,
    \`\`\`nickel
    compose f g x == f (g x)
    \`\`\`
    "%
      = fun g f x => x |> f |> g,

    flip
      : forall a b c. (a -> b -> c) -> b -> a -> c
      | doc m%%"
    Flip the argument order for a two-argument function. For example,
    \`\`\`nickel
    flip (fun x y => "%{x} %{y}") "world!" "Hello,"
      => "Hello, world!"
    \`\`\`
    "%%
      = fun f x y => f y x,

    first
      : forall a b. a -> b -> a
      | doc m%"
    Always returns the first argument:
    \`\`\`nickel
    first 5 7 => 5
    \`\`\`
    "%
      = const,

    second
      : forall a b. a -> b -> b
      | doc m%"
    Always returns the second argument:
    \`\`\`nickel
    second 5 7 => 7
    \`\`\`
    "%
      = flip const,

    pipe
      : forall a. a -> Array (a -> a) -> a
      | doc m%%"
      Apply an array of functions to a value, in order.

      For example:
      \`\`\`nickel
      pipe 2 [ (+) 2, (+) 3 ]
        => 7
      pipe \`World [ string.from, fun s => "Hello, %{s}!" ]
        => "Hello, World!"
      \`\`\`
    "%%
      = fun x fs => array.fold_left (|>) x fs,
  },

  # Internal operations. Can't be accessed from user code because \`$\` is not a
  # valid starting character for an identifier.

  # Contract implementations
  "$dyn" = fun _label value => value,

  "$num" = fun label value => if %typeof% value == \`Number then value else %blame% label,

  "$bool" = fun label value => if %typeof% value == \`Bool then value else %blame% label,

  "$string" = fun label value => if %typeof% value == \`String then value else %blame% label,

  "$fail" = fun label _value => %blame% label,

  "$array" = fun element_contract label value =>
    if %typeof% value == \`Array then
      %array_lazy_assume% (%go_array% label) value element_contract
    else
      %blame% label,

  "$func" = fun domain codomain label value =>
    if %typeof% value == \`Function then
      (fun x => %assume% codomain (%go_codom% label) (value (%assume% domain (%chng_pol% (%go_dom% label)) x)))
    else
      %blame% label,

  "$forall_var" = fun sealing_key label value =>
    let current_polarity = %polarity% label in
    let polarity = (%lookup_type_variable% sealing_key label).polarity in
    if polarity == current_polarity then
      %unseal% sealing_key value (%blame% label)
    else
      # Here, we know that this term should be sealed, but to give the right
      # blame for the contract, we have to change the polarity to match the
      # polarity of the \`Forall\`, because this is what's important for
      # blaming polymorphic contracts.
      %seal% sealing_key (%chng_pol% label) value,

  "$forall" = fun sealing_key polarity contract label value =>
    contract (%insert_type_variable% sealing_key polarity label) value,

  "$enums" = fun case label value =>
    if %typeof% value == \`Enum then
      %assume% case label value
    else
      %blame% (%label_with_message% "not an enum tag" label),

  "$enum_fail" = fun label =>
    %blame% (%label_with_message% "tag not included in the enum type" label),

  "$record" = fun field_contracts tail_contract label value =>
    if %typeof% value == \`Record then
      # Returns the sub-record of \`l\` containing only those fields which are not
      # present in \`r\`. If \`l\` has a sealed polymorphic tail then it will be
      # preserved.
      let field_diff =
        fun left right =>
          array.fold_left (fun acc field =>
            if %has_field% field right then
              acc
            else
              %record_insert% field acc (left. "%{field}")) (%record_empty_with_tail% left) (%fields% left)
      in
      let contracts_not_in_value = field_diff field_contracts value in
      let missing_fields = %fields% contracts_not_in_value in
      if %length% missing_fields == 0 then
        let tail_fields = field_diff value field_contracts in
        let fields_with_contracts =
          array.fold_left (fun acc field =>
            if %has_field% field field_contracts then
              let contract = field_contracts. "%{field}" in
              let label = %go_field% field label in
              let val = value. "%{field}" in
              %record_insert% field acc (%assume% contract label val)
            else
              acc) {} (%fields% value)
        in
        tail_contract fields_with_contracts label tail_fields
      else
        let plural = if %length% missing_fields == 1 then "" else "s" in
        %blame% (%label_with_message%"missing field%{plural} \`%{string.join ", " missing_fields}\`" label)
    else
      %blame% (%label_with_message% "not a record" label),

  "$dyn_record" = fun contract label value =>
    if %typeof% value == \`Record then
      %dictionary_assume% (%go_dict% label) value contract
    else
      %blame% (%label_with_message% "not a record" label),

  "$forall_tail" = fun sealing_key acc label value =>
    let current_polarity = %polarity% label in
    let polarity = (%lookup_type_variable% sealing_key label).polarity in
    if polarity == current_polarity then
      if value == {} then
        let tagged_label = %label_with_message% "polymorphic tail mismatch" label in
        let tail = %record_unseal_tail% sealing_key tagged_label value in
        acc & tail
      else
        let extra_fields = %fields% value in
        let plural = if %length% extra_fields == 1 then "" else "s" in
        %blame% (%label_with_message%"extra field%{plural} \`%{string.join ", " extra_fields}\`" label)
    else
      # Note: in order to correctly attribute blame, the polarity of \`l\`
      # must match the polarity of the \`forall\` which introduced the
      # polymorphic contract (i.e. \`pol\`). Since we know in this branch
      # that \`pol\` and \`%polarity% l\` differ, we swap \`l\`'s polarity before
      # we continue.
      %record_seal_tail% sealing_key (%chng_pol% label) acc value,

  "$dyn_tail" = fun acc label value => acc & value,

  "$empty_tail" = fun acc label value =>
    if value == {} then
      acc
    else
      let extra_fields = %fields% value in
      let plural = if %length% extra_fields == 1 then "" else "s" in
      %blame% (%label_with_message%"extra field%{plural} \`%{string.join ", " extra_fields}\`" label),

  # Recursive priorities operators

  "$rec_force" = fun value => %rec_force% (%force% value),
  "$rec_default" = fun value => %rec_default% (%force% value),

  number = {
    Integer
      | doc m%"
      Contract to enforce a number is an integer.

      For example:
      \`\`\`nickel
        (1.5 | Integer) =>
          error
        (42 | Integer) =>
          42
      \`\`\`
      "%
      = fun label value =>
        if %typeof% value == \`Number then
          if value % 1 == 0 then
            value
          else
            %blame% (%label_with_message% "not an integer" label)
        else
          %blame% (%label_with_message% "not a number" label),

    Nat
      | doc m%"
      Contract to enforce a number is a natural number (including 0).

      For example:
      \`\`\`nickel
        (42 | Nat) =>
          42
        (0 | Nat) =>
          0
        (-4 | Nat) =>
          error
      \`\`\`
      "%
      = fun label value =>
        if %typeof% value == \`Number then
          if value % 1 == 0 && value >= 0 then
            value
          else
            %blame% (%label_with_message% "not a natural" label)
        else
          %blame% (%label_with_message% "not a number" label),

    PosNat
      | doc m%"
      Contract to enforce a number is a positive natural number.

      For example:
      \`\`\`nickel
        (42 | PosNat) =>
          42
        (0 | PosNat) =>
          error
        (-4 | PosNat) =>
          error
      \`\`\`
      "%
      = fun label value =>
        if %typeof% value == \`Number then
          if value % 1 == 0 && value > 0 then
            value
          else
            %blame% (%label_with_message% "not positive integer" label)
        else
          %blame% (%label_with_message% "not a number" label),

    NonZero
      | doc m%"
      Contract to enforce a number is anything but zero.

      For example:
      \`\`\`nickel
        (1 | NonZero) =>
          1
        (0.0 | NonZero) =>
          error
      \`\`\`
      "%
      = fun label value =>
        if %typeof% value == \`Number then
          if value != 0 then
            value
          else
            %blame% (%label_with_message% "non-zero" label)
        else
          %blame% (%label_with_message% "not a number" label),

    is_integer
      : Number -> Bool
      | doc m%"
      Checks if the given number is an integer.

      For example:
      \`\`\`nickel
        is_int 42 =>
          true
        is_int 1.5 =>
          false
      \`\`\`
      "%
      = fun x => x % 1 == 0,

    min
      : Number -> Number -> Number
      | doc m%"
      Results in the lowest of the given two numbers.

      For example:
      \`\`\`nickel
        min (-1337) 42 =>
          -1337
      \`\`\`
      "%
      = fun x y => if x <= y then x else y,

    max
      : Number -> Number -> Number
      | doc m%"
      Results in the highest of the given two numbers.

      For example:
      \`\`\`nickel
        max (-1337) 42 =>
          42
      \`\`\`
      "%
      = fun x y => if x >= y then x else y,

    floor
      : Number -> Number
      | doc m%"
      Rounds the number down to the next integer.

      For example:
      \`\`\`nickel
        floor 42.5 =>
          42
      \`\`\`
      "%
      = fun x =>
        if x >= 0 then
          x - (x % 1)
        else
          x - 1 - (x % 1),

    abs
      : Number -> Number
      | doc m%"
      Results in the absolute value of the given number.

      For example:
      \`\`\`nickel
        abs (-5) =>
          5
        abs 42 =>
          42
      \`\`\`
      "%
      = fun x => if x < 0 then -x else x,

    fract
      : Number -> Number
      | doc m%"
      Results in the fractional part of the given number.

      For example:
      \`\`\`nickel
        fract 13.37 =>
          0.37
        fract 42 =>
          0
      \`\`\`
      "%
      = fun x => x % 1,

    truncate
      : Number -> Number
      | doc m%"
      Truncates the given number.

      For example:
      \`\`\`nickel
        truncate (-13.37) =>
          -13
        truncate 42.5 =>
          42
      \`\`\`
      "%
      = fun x => x - (x % 1),

    pow
      : Number -> Number -> Number
      | doc m%"
      \`pow x y\` results in \`x\` to the power of \`y\`.

      For example:
      \`\`\`nickel
        pow 2 8 =>
          256
      \`\`\`

      # Precision

      Nickel numbers are arbitrary precision rationals. If the exponent \`y\` is
      an integer which fits in a 64-bits signed or unsigned integer (that is, if
      \`y\` is an integer between \`−2^63\` and \`2^64-1\`), the result is computed
      exactly.

      Otherwise, both operands \`x\` and \`y\` are converted to the nearest 64 bits
      float (excluding \`NaN\` and infinity), and we compute the result as a 64
      bits float. This result is then converted back to a rational. In this
      case, **be aware that both the conversion from rationals to floats, and
      the power operation, might incur rounding errors**.
      "%
      = fun x n => %pow% x n,
  },

  record = {
    map
      : forall a b. (String -> a -> b) -> { _ : a } -> { _ : b }
      | doc m%"
      Maps a function on every field of a record. The string argument of the function argument is the name of the
      field.

      For example:
      \`\`\`nickel
        map (fun s x => s) { hi = 2 } =>
          { hi = "hi" }
        map (fun s x => x + 1) { hello = 1, world = 2 } =>
          { hello = 2, world = 3 }
      \`\`\`
      "%
      = fun f r => %record_map% r f,

    fields
      : forall a. { _ : a } -> Array String
      | doc m%"
      Given a record, results in a array of the string representation of all fields in the record.

      \`\`\`nickel
        fields { one = 1, two = 2 } =>
          [ "one", "two" ]
      \`\`\`
      "%
      = fun r => %fields% r,

    values
      : forall a. { _ : a } -> Array a
      | doc m%"
      Given a record, results in a array containing all the values in that record.

      \`\`\`nickel
        values { one = 1, world = "world" }
          [ 1, "world" ]
      \`\`\`
      "%
      = fun r => %values% r,

    has_field
      : forall a. String -> { _ : a } -> Bool
      | doc m%"
      Given the name of a field and a record, checks if the record contains the given field.

      \`\`\`nickel
        has_field "hello" { one = 1, two = 2 } =>
          false
        has_field "one" { one = 1, two = 2 } =>
          true
      \`\`\`
      "%
      = fun field r => %has_field% field r,

    insert
      : forall a. String -> a -> { _ : a } -> { _ : a }
      | doc m%%"
        Insert a new field in a record. \`insert\` doesn't mutate the original
        record but returns a new one instead.

        \`\`\`nickel
        insert "foo" foo { bar = "bar" } =>
          { foo = "foo", bar = "bar }

        {}
        |> insert "file.%{ext}" "data/text"
        |> insert "length" 10*1000 =>
          {"file.txt" = "data/text", "length" = 10000}
        \`\`\`
      "%%
      = fun field content r => %record_insert% field r content,

    remove
      : forall a. String -> { _ : a } -> { _ : a }
      | doc m%"
        Remove a field from a record. \`remove\` doesn't mutate the original
        record but returns a new one instead.

        \`\`\`nickel
        remove "foo" foo { foo = "foo", bar = "bar" } =>
          { bar = "bar }
        \`\`\`
      "%
      = fun field r => %record_remove% field r,

    update
      : forall a. String -> a -> { _ : a } -> { _ : a }
      | doc m%"
        Update a field of a record with a new value. \`update\` doesn't mutate the
        original record but returns a new one instead. If the field to update is absent
        from the given record, \`update\` simply adds it.

        \`\`\`nickel
        remove "foo" foo { foo = "foo", bar = "bar" } =>
          { bar = "bar" }
        \`\`\`

        As opposed to overriding a value with the merge operator \`&\`, \`update\`
        will only change the specified field and won't automatically update the other
        fields which depend on it:

        \`\`\`nickel
        { foo = bar + 1, bar | default = 0 } & { bar = 1 } =>
          { foo = 2, bar = 1 }
        update "bar" 1 {foo = bar + 1, bar | default = 0 } =>
          { foo = 1, bar = 1 }
        \`\`\`
      "%
      = fun field content r =>
        let r =
          if %has_field% field r then
            %record_remove% field r
          else
            r
        in
        %record_insert% field r content,

    map_values
      : forall a b. (a -> b) -> { _ : a } -> { _ : b }
      | doc m%"
      Maps a function over every field value of a record.

      For example:
      \`\`\`nickel
        map_values (fun x => x + 1) { hi = 2 } =>
          { hi = 3 }
        map (fun x => x + 1) { hello = 1, world = 2 } =>
          { hello = 2, world = 3 }
      \`\`\`
    "%
      = fun f => map (fun _field value => f value),

    to_array
      : forall a. { _ : a } -> Array { field : String, value : a }
      | doc m%"
      Converts a record to an array of key-value pairs.

      For example:
      \`\`\`nickel
        to_array { hello = "world", foo = "bar" } =>
          [ { field = "hello", value = "world" },
            { field = "foo", value = "bar" }
          ]
      \`\`\`
    "%
      = fun record =>
        record
        |> fields
        |> array.map (fun field' => { field = field', value = record. "%{field'}" }),

    from_array
      : forall a. Array { field : String, value : a } -> { _ : a }
      | doc m%"
      Convert an array of key-value pairs into a record.

      For example:
      \`\`\`nickel
        from_array [ { field = "hello", value = "world" },
                     { field = "foo", value = "bar" }
                   ]
          => { hello = "world", foo = "bar" }
      \`\`\`
    "%
      = fun bindings =>
        bindings
        |> array.map (fun binding => {"%{binding.field}" = binding.value })
        |> merge_all,

    is_empty
      : forall a. { _ : a } -> Bool
      | doc m%"
      Check whether a record is empty.

      \`\`\`nickel
      is_empty {} => true
      is_empty { foo = 1 } => false
      \`\`\`
    "%
      = (==) {},

    merge_all
      | forall a. Array { _ : a } -> { _ : a }
      | doc m%"
      Merge an array of records.

      For example:
      \`\`\`nickel
      merge_array [ { foo = 1 }, { bar = 2 } ]
        => { foo = 1, bar = 2 }
      \`\`\`
    "%
      = array.fold_left (&) {},

    filter
      : forall a. (String -> a -> Bool) -> { _ : a } -> { _ : a }
      | doc m%"
      Filter a record using the given function, which is passed the name and
      value for each key to make a decision.

      For example:
      \`\`\`nickel
      filter (fun name x => x % 2 == 0) { even = 2, odd = 3 }
        => { even = 2 }
      \`\`\`
    "%
      = fun f record =>
        record
        |> to_array
        |> array.filter (fun { field, value } => f field value)
        |> from_array,
  },

  string = {
    BoolLiteral
      | doc m%"
      Contract to enforce the value is a string that represents a boolean literal. Additionally casts "True" to "true"
      and "False" to "false".

      For example:
      \`\`\`nickel
        ("True" | BoolLiteral) =>
          "true"
        ("hello" | BoolLiteral) =>
          error
        (true | BoolLiteral) =>
          error
      \`\`\`
      "%
      = fun l s =>
        if %typeof% s == \`String then
          if s == "true" || s == "True" then
            "true"
          else
            if s == "false" || s == "False" then
              "false"
            else
              %blame% (%label_with_message% "expected \\"true\\" or \\"false\\", got %{s}" l)
        else
          %blame% (%label_with_message% "not a string" l),

    NumLiteral
      | doc m%"
      Contract to enforce the value is a string that represends a numerical value.

      For example:
      \`\`\`nickel
        ("+1.2" | NumLiteral) =>
          "+1.2"
        ("5" | NumLiteral) =>
          "5"
        (42 | NumLiteral) =>
          error
      \`\`\`
      "%
      = let pattern = m%"^[+-]?(\\d+(\\.\\d*)?(e[+-]?\\d+)?|\\.\\d+(e[+-]?\\d+)?)$"% in
      let is_num_literal = %str_is_match% pattern in
      fun l s =>
        if %typeof% s == \`String then
          if is_num_literal s then
            s
          else
            %blame% (%label_with_message% "invalid num literal" l)
        else
          %blame% (%label_with_message% "not a string" l),

    Character
      | doc m%"
      Contract to enforce the value is a character (i.e. a string of length 1).

      For example:
      \`\`\`nickel
        ("e" | Character) =>
          "e"
        ("#" | Character) =>
          "#"
        ("" | Character) =>
          error
        (1 | Character) =>
          error
      \`\`\`
      "%
      = fun l s =>
        if %typeof% s == \`String then
          if length s == 1 then
            s
          else
            %blame% (%label_with_message% "length different than one" l)
        else
          %blame% (%label_with_message% "not a string" l),

    Stringable
      | doc m%"
      Contract to enforce the value is convertible to a string via
      \`builtin.to_string\` or \`string.from\`. Accepted values are:

      - numbers
      - booleans
      - strings
      - enum tags
      - null

      For example:
      \`\`\`nickel
        (\`Foo | Stringable) =>
          \`Foo
        (false | Stringable) =>
          false
        ("bar" ++ "foo" | Stringable) =>
          "barfoo"
        ({foo = "baz"} | Stringable) =>
          error
      \`\`\`
      "%
      = contract.from_predicate (fun value =>
        let type = builtin.typeof value in
        value == null
        || type == \`Number
        || type == \`Bool
        || type == \`String
        || type == \`Enum),

    NonEmpty
      | doc m%"
      Contract to enforce the value is a non-empty string.

      For example:
      \`\`\`nickel
        ("" | NonEmpty) =>
          error
        ("hi!" | NonEmpty) =>
          "hi!"
        (42 | NonEmpty) =>
          error
      \`\`\`
      "%
      = fun l s =>
        if %typeof% s == \`String then
          if %str_length% s > 0 then
            s
          else
            %blame% (%label_with_message% "empty string" l)
        else
          %blame% (%label_with_message% "not a string" l),

    join
      : String -> Array String -> String
      | doc m%"
      Joins a array of strings given a separator.

      For example:
      \`\`\`nickel
        join ", " [ "Hello", "World!" ] =>
          "Hello, World!"
      \`\`\`
      "%
      = fun sep fragments =>
        let length = %length% fragments in
        if length == 0 then
          ""
        else
          let first = %elem_at% fragments 0 in
          let rest =
            %array_slice% 1 length fragments
            |> array.fold_left (fun acc s => acc ++ sep ++ s) ""
          in
          first ++ rest,

    split
      : String -> String -> Array String
      | doc m%"
      Splits a string based on a separator string. The separator string is not included in any string.

      For example:
      \`\`\`nickel
      split "," "1,2,3" =>
        [ "1", "2", "3" ]
      split "." "1,2,3" =>
        [ "1,2,3" ]
      \`\`\`
      "%
      = fun sep s => %str_split% s sep,

    trim
      : String -> String
      | doc m%"
      Trims whitespace from the start and end of the string.

      For example:
      \`\`\`nickel
      trim " hi  " =>
        "hi"
      trim "1   2   3   " =>
        "1   2   3"
      \`\`\`
      "%
      = fun s => %str_trim% s,

    characters
      : String -> Array String
      | doc m%"
      Separates a string into its individual characters.

      For example:
      \`\`\`nickel
        chars "Hello" =>
          [ "H", "e", "l", "l", "o" ]
      \`\`\`
      "%
      = fun s => %str_chars% s,

    codepoint
      | Character -> Number
      | doc m%%"
      Results in the unicode codepoint of the given character if it fits into a single codepoint.

      For example:
      \`\`\`nickel
        code "A" =>
          65
        code "%" =>
          37
        code "å" =>
          error
      \`\`\`
      "%%
      = fun s => %char_code% s,

    from_codepoint
      | Number -> Character
      | doc m%%"
      Results in the character for a given unicode codepoint.

      For example:
      \`\`\`nickel
        from_code 65 =>
          "A"
        from_code 37 =>
          "%"
        from_code 128 =>
          error
      \`\`\`
      "%%
      = fun s => %char_from_code% s,

    uppercase
      : String -> String
      | doc m%"
      Results in the uppercase version of the given character (including non-ascii characters) if it exists, the same
      character if not.

      For example:
      \`\`\`nickel
        uppercase "a" =>
          "A"
        uppercase "æ" =>
          "Æ"
        uppercase "." =>
          "."
      \`\`\`
      "%
      = fun s => %str_uppercase% s,

    lowercase
      : String -> String
      | doc m%"
      Results in the lowercase version of the given character (including non-ascii characters) if it exists, the same
      character if not.

      For example:
      \`\`\`nickel
        lowercase "A" =>
          "a"
        lowercase "Æ" =>
          "æ"
        lowercase "." =>
          "."
      \`\`\`
      "%
      = fun s => %str_lowercase% s,

    contains
      : String -> String -> Bool
      | doc m%"
      Checks if the first string is part of the second string.

      For example:
      \`\`\`nickel
        contains "cde" "abcdef" =>
          true
        contains "" "abcdef" =>
          true
        contains "ghj" "abcdef" =>
          false
      \`\`\`
      "%
      = fun subs s => %str_contains% s subs,

    replace
      : String -> String -> String -> String
      | doc m%"
      \`replace sub repl String\` replaces every occurrence of \`sub\` in \`String\` with \`repl\`.

      For example:
      \`\`\`nickel
        replace "cd" "   " "abcdef" =>
          "ab   ef"
        replace "" "A" "abcdef" =>
          "AaAbAcAdAeAfA"
      \`\`\`
      "%
      = fun pattern replace s =>
        %str_replace% s pattern replace,

    replace_regex
      : String -> String -> String -> String
      | doc m%"
      \`replace_regex regex repl String\` replaces every match of \`regex\` in \`String\` with \`repl\`.

      For example:
      \`\`\`nickel
        replace_regex "l+." "j" "Hello!" =>
          "Hej!"
        replace_regex "\\\\d+" "\\"a\\" is not" "This 37 is a number." =>
          "This \\"a\\" is not a number."
      \`\`\`
      "%
      = fun pattern replace s =>
        %str_replace_regex% s pattern replace,

    is_match
      : String -> String -> Bool
      | doc m%"
      \`is_match regex String\` checks if \`String\` matches \`regex\`.

      For example:
      \`\`\`nickel
        is_match "^\\\\d+$" "123" =>
          true
        is_match "\\\\d{4}" "123" =>
          false
      \`\`\`

      For example, in the following program, the whole call to
      \`string.is_match "[0-9]*\\\\.?[0-9]+ x"\` is re-evaluated at each invocation of
      \`is_number\`. The regexp will be recompiled 3 times in total:

      \`\`\`nickel
      let is_number = fun x => string.is_match "[0-9]*\\\\.?[0-9]+" x in
      ["0", "42", "0.5"] |> array.all is_number =>
        true
      \`\`\`

      On the other hand, in the version below, the partial application of
      \`string.is_match "[0-9]*\\\\.?[0-9]+"\` is evaluated once, returning a
      function capturing the compiled regexp. The regexp will only be compiled
      once and for all:

      \`\`\`nickel
      let is_number' = string.is_match "[0-9]*\\\\.?[0-9]+" in
      ["0", "42", "0.5"] |> array.all is_number' =>
        true
      \`\`\`
      "%
      = fun regex => %str_is_match% regex,

    find
      : String -> String -> { matched : String, index : Number, groups : Array String }
      | doc m%"
      \`find regex String\` matches \`String\` given \`regex\`. Results in the part of \`String\` that matched, the index of the
      first character that was part of the match in \`String\`, and a arrays of all capture groups if any.

      For example:
      \`\`\`nickel
        find "^(\\\\d).*(\\\\d).*(\\\\d).*$" "5 apples, 6 pears and 0 grapes" =>
          { matched = "5 apples, 6 pears and 0 grapes", index = 0, groups = [ "5", "6", "0" ] }
        find "3" "01234" =>
          { matched = "3", index = 3, groups = [ ] }
      \`\`\`

      Note that this function may perform better by sharing its partial application between multiple calls,
      because in this case the underlying regular expression will only be compiled once (See the documentation
      of \`string.is_match\` for more details).
      "%
      = fun regex => %str_find% regex,

    length
      : String -> Number
      | doc m%"
      Returns the length of the string, as measured by the number of UTF-8
      [extended grapheme clusters](https://unicode.org/glossary/#extended_grapheme_cluster).

      Generally speaking, this gives the number of "visible" glyphs in the string.

      For example:
      \`\`\`nickel
        length "" =>
          0
        length "hi" =>
          2
        length "四字熟語" =>
          4
        length "👨🏾‍❤️‍💋‍👨🏻" =>
          1
      \`\`\`
      "%
      = fun s => %str_length% s,

    substring
      : Number -> Number -> String -> String
      | doc m%"
      Takes a slice from the string. Errors if either index is out of range.

      For example:
      \`\`\`nickel
        substring 3 5 "abcdef" =>
          "de"
        substring 3 10 "abcdef" =>
          error
        substring (-3) 4 "abcdef" =>
          error
      \`\`\`
      "%
      = fun start end s => %str_substr% s start end,

    from
      | Stringable -> String
      | doc m%"
      Converts a correct value to a string representation. Same as
      \`builtin.to_string\`.

      For example:
      \`\`\`nickel
      from 42 =>
        "42"
      from \`Foo =>
        "Foo"
      from null =>
        "null"
      "%
      = fun x => %to_str% x,

    from_number
      | Number -> String
      | doc m%"
      Converts a number to its string representation.

      For example:
      \`\`\`nickel
      from_number 42 =>
        "42"
      \`\`\`
      "%
      = from,

    # from_enum | < | Dyn> -> String = fun tag => %to_str% tag,
    from_enum
      | enum.Tag -> String
      | doc m%"
      Converts an enum variant to its string representation.

      For example:
      \`\`\`nickel
      from_enum \`MyEnum =>
        "MyEnum"
      \`\`\`
      "%
      = from,

    from_bool
      | Bool -> String
      | doc m%"
      Converts a boolean value to its string representation.

      For example:
      \`\`\`nickel
        from_bool true =>
          "true"
      \`\`\`
      "%
      = from,

    to_number
      | NumLiteral -> Number
      | doc m%"
      Converts a string that represents an integer to that integer.

      For example:
      \`\`\`nickel
        to_number "123" =>
          123
      \`\`\`
      "%
      = fun s => %num_from_str% s,

    to_bool
      | BoolLiteral -> Bool
      | doc m%"
      Converts a string that represents a boolean to that boolean.

      For example:
      \`\`\`nickel
        to_bool "true" =>
          true
        to_bool "True" =>
          true
        to_bool "false" =>
          false
      \`\`\`
      "%
      = fun s => s == "true",

    # to_enum | String -> < | Dyn> = fun s => %enum_from_str% s,
    to_enum
      | String -> enum.Tag
      | doc m%"
      Converts any string that represents an enum variant to that enum variant.

      For example:
      \`\`\`nickel
        to_enum "Hello" =>
          \`Hello
      \`\`\`
      "%
      = fun s => %enum_from_str% s,
  }
}
`,
  },
  "ocaml": {
    query: `; Configuration
(#language! ocaml)

; This query file is used to format trees produced by two different grammars:
; - the grammar for OCaml interface files \`tree_sitter_ocaml::language_ocaml_interface()\`
; - the grammar for OCaml implementation files \`tree_sitter_ocaml::language_ocaml()\`

; On certain cases, some files may correctly parse with both grammars, but produce
; different syntax trees. We want those files to be formatted the same way,
; independently of the grammar used to parse them.

; To ensure this property, we introduce equivalence classes on syntax node types.
; Simply put, if two node types are in the same equivalence class, then they must
; appear in the same queries.

; If you add or modify a query containing a node type in one of the equivalence classes,
; please make sure to add or modify the corresponding queries for all other node types
; in the same equivalence class.

; The equivalence classes are the following:
; - include_module, include_module_type
; - module_path, extended_module_path, module_type_path
; - module_name, module_type_name

; Sometimes we want to indicate that certain parts of our source text should
; not be formatted, but taken as is. We use the leaf capture name to inform the
; tool of this.
(
  [
    (character)
    (quoted_string)
    (signed_number)
    (string)
  ]
) @leaf

; line number directives must be alone on their line, and can't be indented
(line_number_directive) @single_line_no_indent

; Allow blank line before
[
  (class_definition)
  (class_type_definition)
  (comment)
  (exception_definition)
  (external)
  (floating_attribute)
  ; start equivalence class
  (include_module)
  (include_module_type)
  ; end equivalence class
  (inheritance_definition)
  (inheritance_specification)
  (instance_variable_definition)
  (method_definition)
  (module_definition)
  (module_type_definition)
  (open_module)
  (type_definition)
  (value_definition)
  (value_specification)
] @allow_blank_line_before

; In a definition including several mutually recursive functions,
; one can skip a line before each of them.
(value_definition
  "and" @allow_blank_line_before
)
(value_definition
  (and_operator) @allow_blank_line_before
)

; Append line breaks. If there is a comment following, we don't add anything,
; because the input softlines and spaces above will already have sorted out the
; formatting.
(
  [
    (exception_definition)
    (external)
    (module_definition)
    (module_type_definition)
    (type_definition)
  ] @append_hardline
  .
  "in"? @do_nothing
  .
  (comment)* @do_nothing
)
; Also append line breaks after open_module, except when it's
; preceded by "let", because in this case it's in a let_open_expression.
(
  "let"? @do_nothing
  .
  (open_module) @append_hardline
  .
  (comment)* @do_nothing
)

; Append line break after module include, except if it's alone in a single-lined struct
(
  [
    ; start equivalence class
    (include_module)
    (include_module_type)
    ; end equivalence class
  ] @append_hardline
  .
  "end"? @do_nothing
)
(structure
  "struct"
  .
  [
    ; start equivalence class
    (include_module)
    (include_module_type)
    ; end equivalence class
  ] @append_spaced_softline
  .
  "end"
)

; Consecutive definitions must be separated by line breaks
(
  [
    (value_definition)
    (value_specification)
  ] @append_hardline
  .
  [
    (exception_definition)
    (external)
    (module_definition)
    (module_type_definition)
    (open_module)
    (type_definition)
    (value_definition)
    (value_specification)
  ]
)

; Surround spaces
; A space is put after, and before (except just after an open parenthesis).
(
  [
    "and"
    "as"
    "assert"
    "class"
    "constraint"
    "downto"
    "else"
    "exception"
    "external"
    (floating_attribute)
    "for"
    "if"
    "in"
    "include"
    (infix_operator)
    "inherit"
    (item_attribute)
    "let"
    "match"
    "method"
    "module"
    (module_parameter)
    "mutable"
    "new"
    "nonrec"
    "object"
    "of"
    "open"
    (parameter)
    "private"
    "rec"
    "sig"
    "then"
    "to"
    "try"
    "type"
    "val"
    "virtual"
    "when"
    "while"
    "with"
    "*"
    "="
    "|"
    "||"
    "->"
    "<-"
    "{"
    ":"
    ";"
    "+="
    ":="
    ":>"
    "::"
    "[>"
    "[<"
  ] @append_space
  .
  "%"? @do_nothing
)

; Those keywords are not expected to come right after an open parenthesis.
[
  "as"
  "constraint"
  "do"
  "done"
  "downto"
  "else"
  "in"
  "nonrec"
  "of"
  "rec"
  "then"
  "to"
  "virtual"
  "when"
  "with"
  "|"
  "->"
  "<-"
  "+="
  ":="
  ":>"
  "::"
] @prepend_space

; let-like and and-like operators are only followed by a closing parenthesis
; during their definition, in which case no space must be appended.
; space must be appended otherwise
(
  (and_operator) @append_space
  .
  ")"* @do_nothing
)
(
  (let_operator) @append_space
  .
  ")"* @do_nothing
)

; For those queries, we should not have multiple queries,
; however, due to a known bug in tree-sitter queries
; https://github.com/tree-sitter/tree-sitter/issues/1811
; using an alternative after the starred parenthesis does not work as intented.
;
(
  "("* @do_nothing
  .
  "assert" @prepend_space
)
(
  "("* @do_nothing
  .
  (attribute) @prepend_space
)
(
  "("* @do_nothing
  .
  "begin" @prepend_space
)
(
  "("* @do_nothing
  .
  "class" @prepend_space
)
(
  "("* @do_nothing
  .
  "exception" @prepend_space
)
(
  "("* @do_nothing
  .
  "external" @prepend_space
)
(
  "("* @do_nothing
  .
  (floating_attribute) @prepend_space
)
(
  "("* @do_nothing
  .
  "for" @prepend_space
)
(
  "("* @do_nothing
  .
  "include" @prepend_space
)
(
  "("* @do_nothing
  .
  (infix_operator) @prepend_space
)
(
  "("* @do_nothing
  .
  "inherit" @prepend_space
)
(
  "("* @do_nothing
  .
  (item_attribute) @prepend_space
)
(
  "("* @do_nothing
  .
  "let" @prepend_space
)
(
  "("* @do_nothing
  .
  "method" @prepend_space
)
(
  "("* @do_nothing
  .
  "module" @prepend_space
)
(
  "("* @do_nothing
  .
  (module_parameter) @prepend_space
)
(
  "("* @do_nothing
  .
  "mutable" @prepend_space
)
(
  "("* @do_nothing
  .
  "new" @prepend_space
)
(
  "("* @do_nothing
  .
  "object" @prepend_space
)
(
  "("* @do_nothing
  .
  "open" @prepend_space
)
(
  "("* @do_nothing
  .
  (parameter) @prepend_space
)
(
  "("* @do_nothing
  .
  "private" @prepend_space
)
(
  "("* @do_nothing
  .
  "sig" @prepend_space
)
(
  "("* @do_nothing
  .
  "try" @prepend_space
)
(
  "("* @do_nothing
  .
  "type" @prepend_space
)
(
  "("* @do_nothing
  .
  "val" @prepend_space
)
(
  "("* @do_nothing
  .
  "while" @prepend_space
)
(
  "("* @do_nothing
  .
  "*" @prepend_space
)
(
  "("* @do_nothing
  .
  "=" @prepend_space
)
(
  "("* @do_nothing
  .
  "||" @prepend_space
)
(
  "("* @do_nothing
  .
  "}" @prepend_space
)

; Put a space after commas, except the last one.
(
  "," @append_space
  .
  (_)
)

; Put a space after the dot in polymorphic function types
;
; let my_const :
;   type a b. a: a -> b: b -> a =
;   fun ~a ~b -> a
(polymorphic_type
  "." @append_space
)

; Certain elements must be separated by spaces.
(
  [
    (boolean)
    (character)
    (class_path)
    (class_type_path)
    (constructed_type)
    (constructor_path)
    (extension)
    (field_get_expression)
    (hash_type)
    (labeled_argument)
    ; start equivalence class
    (extended_module_path)
    (module_path)
    (module_type_path)
    ; end equivalence class
    (number)
    (parenthesized_expression)
    (parenthesized_pattern)
    (polymorphic_variant_type)
    (quoted_string)
    (string)
    (tag)
    (type_constructor)
    (type_constructor_path)
    (typed_expression)
    (type_variable)
    (value_name)
    (value_path)
    (value_pattern)
    ")"
    "]"
  ] @append_space
  .
  [
    ; Don't add any space just before these.
    ","
    ";"
    "."
    ".."
    ")"
    "]"
  ]* @do_nothing
  .
  [
    (abstract_type)
    (boolean)
    (character)
    (class_name)
    (class_path)
    (class_type_name)
    (class_type_path)
    (constructed_type)
    (constructor_path)
    (constructor_pattern)
    (field_get_expression)
    (local_open_pattern)
    (labeled_argument)
    ; start equivalence class
    (extended_module_path)
    (module_path)
    (module_type_path)
    ; end equivalence class
    (number)
    (parenthesized_expression)
    (parenthesized_pattern)
    (polymorphic_variant_type)
    (prefix_expression)
    (quoted_string)
    (range_pattern)
    (string)
    (tag)
    (type_constructor)
    (type_constructor_path)
    (type_variable)
    (typed_expression)
    (value_name)
    (value_path)
    (value_pattern)
    "("
    "{"
  ]
)

; When one uses a language extension, we always put a space after the extension name,
; if this name ends by the '?' or ':' token, the space comes after it.
;
(
  (attribute_id) @append_space
  .
  (attribute_payload
    [
      "?"
      ":"
    ]
  )* @do_nothing
)
(attribute_payload
  [
    "?"
    ":"
  ] @append_space
)

; Some kinds of colons should have a space in front.
(
  [
    (constructor_name)
    (fun_expression)
    (parenthesized_expression)
    (value_name)
    (value_pattern)
  ] @append_space
  .
  ":"
)

; Keep spacing between pointy brackets when used in object types.
;
; This is syntactically correct:
;   let obj_id (obj : < .. >) = obj
; This is not:
;   let obj_id (obj : <..>) = obj
(object_type
  "<" @append_space
  ">" @prepend_space
)

; Softlines. These become either a space or a newline, depending on whether we
; format their node as single-line or multi-line. If there is a comment
; following, we don't add anything, because they will have their own line break
; processing applied to them.
;
; If those keywords are followed by a ppx extension,
; the soft linebreak comes after it.
(
  [
    "begin"
    "do"
    "in"
    "of"
    "struct"
    "then"
    "with"
    "{"
    ";"
  ] @append_spaced_softline
  .
  [
    (attribute)
    (comment)
    "%"
  ]* @do_nothing
)

(
  [
    "begin"
    "do"
    "in"
    "of"
    "struct"
    "then"
    "with"
    "{"
    ";"
  ]
  .
  "%"
  .
  (attribute_id) @append_spaced_softline
  .
  (comment)* @do_nothing
)

(type_binding
  (type_constraint) @prepend_spaced_softline
)

; only add softlines after "else" if it's not part of an "else if" construction
(
  "else" @append_spaced_softline
  .
  [
    (comment)
    (if_expression)
  ]? @do_nothing
)

; ":" must not always be followed by a softline, we explicitly enumerate
; the contexts where it must happen
(value_specification
  ":" @append_spaced_softline
)
(module_binding
  ":" @append_input_softline
)
(field_declaration
  ":" @append_spaced_softline
)
(typed_label
  ":" @append_spaced_softline
)
(constructor_declaration
  ":" @append_spaced_softline
)

; "->" must not always be followed by a softline, we explicitly enumerate
; the contexts where it must happen
(fun_expression
  "->" @append_spaced_softline
)
(match_case
  "->" @append_spaced_softline
)
(constructor_declaration
  "->" @append_spaced_softline
)

; Always put softlines before these:
[
  "and"
  "done"
  "end"
  (else_clause)
  (infix_operator)
  (item_attribute)
  "*"
  "|"
  "}"
] @prepend_spaced_softline

[
  (match_expression)
] @prepend_empty_softline

; Softline before the first match case
;
; let type_constant = function
;   Const_int _ -> instance Predef.type_int
;   | Const_char _ -> instance Predef.type_char
;
(match_expression
  "|"* @do_nothing
  .
  (match_case) @prepend_spaced_softline
)

; Allow (and enforce) the optional "|" before the first match case
; if and only if the context is multi-line
(
  "with"
  .
  "|" @delete
  .
  (match_case)
  (#single_line_only!)
)

(
  "with"
  .
  "|"? @do_nothing
  .
  (match_case) @prepend_delimiter
  (#delimiter! "| ") ; sic
  (#multi_line_only!)
)

; Multi-line definitions must have a linebreak after "=" and before "in":
;
; let a =
;   expression
;   in
;   expression
;
(
  (value_definition
    (_) @append_spaced_softline
    .
  )
  .
  "in"
)
; There are special cases however. We do not want to break lines after "=" when writing
;
; let f = function
;   | Constructor -> expression
;
; or
;
; let f = fun x ->
;   expression
;
(let_binding
  "=" @append_spaced_softline
  .
  [
    (function_expression)
    (fun_expression)
  ]* @do_nothing
)

; We chose not to add a line break between \`=\` and the
; \`fun\` or \`function\` keywords, but in order to keep the multi-lined-ness
; we must add a softline after the arrow. We need custom scopes to do this,
; since the node which contains the arrow may be single-line.
;
; This turns
;
; let foo =
;   fun x -> x
; in
; bar
;
; into
;
; let foo = fun x ->
;   x
; in
; bar
(let_binding
  "=" @begin_scope
  .
  (fun_expression
    "->" @append_spaced_scoped_softline
  ) @end_scope
  (#scope_id! "fun_definition")
)

; The same as above holds for single-line \`function\`.
;
; This turns
; let foo =
;   function true -> false | false -> true
; in
; bar
;
; into
;
; let foo = function
;   | true -> false
;   | false -> true
; in
; bar
(let_binding
  "=" @begin_scope
  .
  (function_expression
    "function" @append_spaced_scoped_softline
  ) @end_scope
  (#scope_id! "function_definition")
)
(parenthesized_expression
  (function_expression
    "function" @append_spaced_scoped_softline
  ) @begin_scope @end_scope
  (#scope_id! "function_definition")
)
(function_expression
  (match_case)? @do_nothing
  .
  "|" @delete
  .
  (match_case)
  (#single_line_scope_only! "function_definition")
)
(function_expression
  "|"? @do_nothing
  .
  (match_case) @prepend_delimiter
  (#multi_line_scope_only! "function_definition")
  (#delimiter! "| ") ; sic
)
(function_expression
  "|" @prepend_spaced_scoped_softline
  .
  (match_case)
  (#scope_id! "function_definition")
)

(value_definition
  (and_operator) @prepend_spaced_softline
)

; There is a large class of terms which should be separated from "=" by a soft line break.
(
  "=" @append_spaced_softline
  .
  [
    (application_expression)
    (class_body_type)
    (constructed_type)
    (if_expression)
    (function_type)
    (let_expression)
    (object_expression)
    (product_expression)
    (record_expression)
    (sequence_expression)
    (set_expression)
    (typed_expression)
    (value_path)
    (variant_declaration)
  ]
)

; In module signature, each symbol declaration is separated by a softline.
;
; module type Name = sig
;   val function1 : type1
;   val function2 : type2
;  end
;
(signature
  "sig" @append_spaced_softline
  [
    (value_specification)
    (type_definition)
    ; start equivalence class
    (include_module)
    (include_module_type)
    ; end equivalence class
  ] @append_spaced_softline
)

; In class definitions and class type definitions, each declaration is separated
; by a softline.

; class foo =
;   object
;     inherit bar
;     val baz = None
;     method qux = None
;   end
;
(object_expression
  "object"
  [
    (inheritance_definition)
    (instance_variable_definition)
    (method_definition)
  ] @append_spaced_softline @prepend_spaced_softline
)

(class_body_type
  "object"
  [
    (inheritance_specification)
    (instance_variable_definition)
    (method_definition)
  ] @append_spaced_softline @prepend_spaced_softline
)

; Move semicolon delimiters just after field declarations,
; before any attributes and comments.
;
; type t =
;   { mutable position : int [@default 0] (* End-of-line comment *);
;   ...
;
; is turned into
;
; type t =
;   {
;     mutable position : int; [@default 0] (* End-of-line comment *)
;     ...
;
(record_declaration
  (field_declaration) @append_delimiter
  .
  [
    (comment)
    (attribute)
  ]*
  .
  ";" @delete
  (#delimiter! ";")
)

(record_declaration
  (field_declaration) @prepend_spaced_softline
)

; Allow multi-line attributes after field declaratioms, such as:
; type t = {
;   bar: float;
;   foo: bool
;     [@default false] (* a comment *)
;     [@other tag] (* and another one *)
;     [@and again] (* and another one *)
;     [@and again]; (* and a last one *)
; }
(record_declaration
  (#scope_id! "field_declaration")
  [
    (field_declaration)
    (attribute)
    (comment)
  ]? @end_scope
  .
  (field_declaration) @begin_scope
)
(record_declaration
  (#scope_id! "field_declaration")
  [
    (field_declaration)
    (attribute)
    (comment)
  ] @end_scope
  .
  "}"
)
(record_declaration
  (attribute) @prepend_indent_start @prepend_spaced_scoped_softline @append_indent_end
  (#scope_id! "field_declaration")
)

; Duplicate the same logic as above for record *expressions*
(record_expression
  (field_expression) @append_delimiter
  .
  [
    (comment)
    (attribute)
  ]*
  .
  ";" @delete
  (#delimiter! ";")
)

(record_expression
  (field_expression) @prepend_spaced_softline
)

(record_expression
  (#scope_id! "field_expression")
  [
    (field_expression)
    (attribute)
    (comment)
  ]? @end_scope
  .
  (field_expression) @begin_scope
)
(record_expression
  (#scope_id! "field_expression")
  [
    (field_expression)
    (attribute)
    (comment)
  ] @end_scope
  .
  "}"
)
(record_expression
  (attribute) @prepend_indent_start @prepend_spaced_scoped_softline @append_indent_end
  (#scope_id! "field_expression")
)

; Start an indented block after these
[
  "begin"
  "do"
  "object"
  "sig"
  "struct"
  "then"
] @append_indent_start

; "{" can be used to start quoted strings. Don't indent in that case
(
  "{" @append_indent_start
  .
  (quoted_string_content)* @do_nothing
)

; End the indented block before these
(
  [
    "done"
    "end"
  ] @prepend_indent_end
)

; "}" can be used to end quoted strings. Don't indent in that case
(
  (quoted_string_content)* @do_nothing
  .
  "}" @prepend_indent_end
)

; Only indent after "else" if it's not an "else if" construction
(
  (else_clause
    "else" @append_indent_start
    (if_expression)? @do_nothing
  ) @append_indent_end
)

; End the indented block after these
(
  (then_clause) @append_indent_end
)

; Make an indented block after ":" in typed expressions
;
; (fun _env _md -> assert false) :
;   Env.t -> Parsetree.module_expr -> Typedtree.module_expr * Shape.t
;
(typed_expression
  ":" @append_indent_start
  (_) @append_indent_end
  .
  ; just doing _ above doesn't work, because it matches the final named node as
  ; well as the final non-named node, causing double indentation.
)

(value_specification
  ":" @append_indent_start
  (_) @append_indent_end
  .
)

; Make an indented block after "=" in
; * class bindings
; * class_type bindings
; * instance variable definitions
; * method definitions
; * type bindings

(class_binding
  "=" @append_indent_start
  (_) @append_indent_end
)

(class_type_binding
  "=" @append_indent_start
  (_) @append_indent_end
)

(instance_variable_definition
  "=" @append_indent_start
  (_) @append_indent_end
)

(method_definition
  "=" @append_indent_start
  (_) @append_indent_end
)

; Don't indent for record types nor polymorphic variant types:
; they are already indented, and we don't process double indentation well enough
(type_binding
  [
    "="
    "+="
  ] @append_indent_start
  .
  [
    (constructed_type)
    (function_type)
    (hash_type)
    (object_type)
    (parenthesized_type)
    (tuple_type)
    (type_constructor_path)
    (type_variable)
    (variant_declaration)
  ] @append_indent_end
  .
  (type_constraint)? @do_nothing
)
(type_binding
  [
    "="
    "+="
  ] @append_indent_start
  .
  [
    (constructed_type)
    (function_type)
    (hash_type)
    (object_type)
    (parenthesized_type)
    (tuple_type)
    (type_constructor_path)
    (type_variable)
    (variant_declaration)
  ]
  .
  (type_constraint) @append_indent_end
)

; Make an indented block after "of" or ":" in constructor declarations
;
; | Expr_type_clash of
;   Errortrace.unification_error * type_forcing_context option
; | Pattern_type_clash :
;   Errortrace.unification_error * Parsetree.pattern_desc option -> error
;
(constructor_declaration
  [
    "of"
    ":"
  ] @append_indent_start
  (_) @append_indent_end
  .
)

; Make an indented block after the first term in a long if expression
;
; if len < 0
;  || srcoff < 0
;  || srcoff > src.position - len then
;
(if_expression
  (infix_expression
    .
    (_) @append_indent_start
    (_) @append_indent_end
    .
  )
)

; Make an indented block after match arrows.
;
; match lid with
; | Ldot(_, "false") ->
;   Boolean
;
(match_case
  "->" @append_indent_start
  (_) @append_indent_end
  .
)

; Make an indented block after constructor declaration arrows.
;
; Errortrace.unification_error * Parsetree.pattern_desc option ->
;   error
;
(constructor_declaration
  "->" @append_indent_start
  (_) @append_indent_end
  .
)

; Make an indented block where a function/match starts in PPX syntax.
(extension
  "[%" @append_indent_start
  "]" @prepend_indent_end @prepend_empty_softline
)

; Indent and add softlines in multiline application expressions, such as
; let _ =
;   long_function
;     long_argument_1
;     long_argument_2
;     long_argument_3
;     long_argument_4
(application_expression
  .
  (_) @append_indent_start
  (_) @append_indent_end
  .
)
(application_expression
  (_) @append_spaced_softline
  .
  (_)
)

; Indent and allow softlines in multiline function definitions, such as
; let long_function
;     (long_argument_1: int)
;     (long_argument_2: int)
;     (long_argument_3: int)
;     (long_argument_4: int)
;     : int
;   =
;   42
(let_binding
  .
  (_) @append_indent_start @append_indent_start
  "=" @prepend_indent_end
  (_) @append_indent_end
  .
)
(let_binding
  .
  (_) @begin_scope
  "=" @end_scope
  (#scope_id! "let_binding_before_equal")
)
(let_binding
  (parameter) @prepend_spaced_scoped_softline
  (#scope_id! "let_binding_before_equal")
)
(let_binding
  ":"? @prepend_spaced_scoped_softline
  "=" @prepend_spaced_scoped_softline
  (#scope_id! "let_binding_before_equal")
)

; Indent and allow softlines in anonymous function definitions, such as
; fun
;   (long_argument_1: int)
;   (long_argument_2: int)
;   (long_argument_3: int)
;   (long_argument_4: int) ->
;   ()
(fun_expression
  .
  "fun" @append_indent_start @append_indent_start
  "->" @prepend_indent_end
  (_) @append_indent_end
  .
)
(fun_expression
  .
  "fun" @begin_scope
  "->" @end_scope
  (#scope_id! "fun_expr_before_arrow")
)
(fun_expression
  (parameter) @prepend_spaced_scoped_softline
  (#scope_id! "fun_expr_before_arrow")
)
(fun_expression
  ":"? @prepend_spaced_scoped_softline
  "->" @prepend_spaced_scoped_softline
  (#scope_id! "fun_expr_before_arrow")
)

; Indent and allow softlines in tuples, such as
; let _ =
;   (
;     long_value_1,
;     long_value_2,
;     long_value_3
;   )
(parenthesized_expression
  .
  "(" @append_empty_softline @append_indent_start
  ")" @prepend_indent_end @prepend_empty_softline
  .
)
; Parenthesis are optional when using tuples, so scopes must be tied
; to the \`product_expression\` inside.
; Product expressions are nested grammar elements, which means that the syntax tree of
; 1, 2, 3
; is
; {Node product_expression}
;   {Node product_expression}
;     {Node number}
;     {Node ,}
;     {Node number}
;   {Node ,}
;   {Node number}
; We only want to define a scope around the outermost \`product_expression\`,
; which is the one that *isn't* followed by a comma.
(
  (product_expression) @begin_scope @end_scope
  .
  ","? @do_nothing
  (#scope_id! "tuple")
)
(product_expression
  "," @append_spaced_scoped_softline
  (#scope_id! "tuple")
)

; Allow softlines in function types, such as
; type t =
;   a ->
;   (b -> c) ->
;   d ->
;   e
; Function types are nested grammar elements, which means that the syntax tree of
; a -> b -> c
; is
; {Node function_type}
;   {Node type_constructor_path}
;     {Node type_constructor}
;   {Node ->}
;   {Node function_type}
;     {Node type_constructor_path}
;       {Node type_constructor}
;     {Node ->}
;     {Node type_constructor_path}
;       {Node type_constructor}
; We only want to define a scope around the outermost \`function_type\` node,
; which is the one that *isn't* preceded by an arrow.
(
  "->"? @do_nothing
  .
  (function_type) @begin_scope @end_scope
  (#scope_id! "function_type")
)
(function_type
  "->" @append_spaced_scoped_softline
  (#scope_id! "function_type")
)

; Allow softlines in infix expressions, such as
; let b =
;   foo
;   || bar
;   || baz

; As above, infix expressions are nested grammar elements, so we must identify the
; top-level one: it is the one that is not preceded by an infix operator.
; We only consider the common logic operators, as not to mess with arithmetic expressions
(
  (infix_operator
    [
      "||"
      "&&"
    ]
  )? @do_nothing
  .
  (infix_expression) @begin_scope @end_scope
  (#scope_id! "infix_expression")
)
(infix_expression
  (infix_operator
    [
      "||"
      "&&"
    ]
  ) @prepend_spaced_scoped_softline
  (#scope_id! "infix_expression")
)

; Allow softlines in sequences and ppx sequences, such as
; let b =
;   foo;
;   bar;
;   baz
; As above, sequences are nested grammar elements, so we must identify the
; top-level one: it is the one that is not preceded by a ";" (or ";%foo" for ppx sequences).
(
  ";"? @do_nothing
  .
  (sequence_expression
    .
    _
    .
    ";"
    .
    "%"? @do_nothing
  ) @begin_scope @end_scope
  (#scope_id! "sequence_expression")
)
(sequence_expression
  ";" @append_spaced_scoped_softline
  (#scope_id! "sequence_expression")
)

(
  ";"?
  .
  "%"? @do_nothing
  .
  (attribute_id)?
  .
  (sequence_expression
    .
    _
    .
    ";"
    .
    "%"
  ) @begin_scope @end_scope
  (#scope_id! "ppx_sequence_expression")
)
(sequence_expression
  ";"
  .
  "%"
  .
  (attribute_id) @append_spaced_scoped_softline
  (#scope_id! "ppx_sequence_expression")
)

; Indent and add softlines in lists and arrays, such as
; let _ =
;   [
;     long_value_1;
;     long_value_2;
;     long_value_3;
;   ]
(list_expression
  .
  "[" @append_indent_start @append_empty_softline
  "]" @prepend_indent_end @prepend_empty_softline
  .
)

(list_pattern
  .
  "[" @append_indent_start @append_empty_softline
  "]" @prepend_indent_end @prepend_empty_softline
  .
)

(array_expression
  .
  "[|" @append_indent_start @append_empty_softline
  "|]" @prepend_indent_end @prepend_empty_softline
  .
)

(array_pattern
  .
  "[|" @append_indent_start @append_empty_softline
  "|]" @prepend_indent_end @prepend_empty_softline
  .
)

; Allow softlines and indentation in functor definitions with many arguments, such as
; module Lift
;   (Credit: module type of CreditSignature)
;   (Dance: module type of DanceSignature)
;   (Tune: module type of TuneSignature)
;   (Version: module type of VersionSignature)
; = struct
;   let foo = x
; end
(module_binding
  (module_name) @append_indent_start @begin_scope
  "=" @prepend_empty_scoped_softline @prepend_indent_end @end_scope
  (#scope_id! "module_binding_before_equal")
)
; if a module binding has no equal sign and isn't just a signature, everything enters the scope
(module_binding
  (#scope_id! "module_binding_before_equal")
  (module_name) @append_indent_start @begin_scope
  "="? @do_nothing
  (signature)? @do_nothing
) @append_indent_end @end_scope
(module_binding
  (module_name) @append_empty_scoped_softline
  (module_parameter) @prepend_spaced_scoped_softline
  (#scope_id! "module_binding_before_equal")
)

; Try block formatting
; A soft linebreak after the "try" (potentially "try%ppx") and one after the "with".
(try_expression
  "try" @append_spaced_softline @append_indent_start
  .
  "%"* @do_nothing
)
(try_expression
  "try"
  .
  "%"
  .
  (attribute_id) @append_spaced_softline @append_indent_start
)
(try_expression
  "with" @prepend_indent_end @prepend_spaced_softline @append_indent_start
  (_) @append_indent_end
  .
)

; Formatting set expressions
(set_expression
  "<-" @append_spaced_softline @append_indent_start
) @append_indent_end

; Input softlines before and after all comments. This means that the input
; decides if a comment should have line breaks before or after. But don't put a
; softline directly in front of commas or semicolons.

(comment) @prepend_input_softline

(
  (comment) @append_input_softline
  .
  ["," ";"]* @do_nothing
)
`,
    input: `(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*    Pierre Weis and Xavier Leroy, projet Cristal, INRIA Rocquencourt    *)
(*                                                                        *)
(*   Copyright 1999 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Extensible buffers *)

type t =
 {mutable buffer : bytes;
  mutable position : int;  (* End-of-line comment *)
  mutable length : int;
  initial_buffer : bytes}
(* Invariants: all parts of the code preserve the invariants that:
   - [0 <= b.position <= b.length]
   - [b.length = Bytes.length b.buffer]

   Note in particular that [b.position = b.length] is legal,
   it means that the buffer is full and will have to be extended
   before any further addition. *)

let create n =
  let n = if n < 1 then 1 else n in
  let n = if n > Sys.max_string_length then Sys.max_string_length else n in
  let s = Bytes.create n in
  {buffer = s; position = 0; length = n; initial_buffer = s}

let contents b = Bytes.sub_string b.buffer 0 b.position
let to_bytes b = Bytes.sub b.buffer 0 b.position

let sub b ofs len =
  if ofs < 0 || len < 0 || ofs > b.position - len
  then invalid_arg "Buffer.sub"
  else Bytes.sub_string b.buffer ofs len


let blit src srcoff dst dstoff len =
  if len < 0 || srcoff < 0 || srcoff > src.position - len
             || dstoff < 0 || dstoff > (Bytes.length dst) - len
  then
    invalid_arg "Buffer.blit"
  else
    Bytes.unsafe_blit src.buffer srcoff dst dstoff len


let nth b ofs =
  if ofs < 0 || ofs >= b.position then
   invalid_arg "Buffer.nth"
  else Bytes.unsafe_get b.buffer ofs


let length b = b.position

let clear b = b.position <- 0

let reset b =
  b.position <- 0;
  b.buffer <- b.initial_buffer;
  b.length <- Bytes.length b.buffer

(* [resize b more] ensures that [b.position + more <= b.length] holds
   by dynamically extending [b.buffer] if necessary -- and thus
   increasing [b.length].

   In particular, after [resize b more] is called, a direct access of
   size [more] at [b.position] will always be in-bounds, so that
   (unsafe_{get,set}) may be used for performance.
*)
let resize b more =
  let old_pos = b.position in
  let old_len = b.length in
  let new_len = ref old_len in
  while old_pos + more > !new_len do new_len := 2 * !new_len done;
  if !new_len > Sys.max_string_length then begin
    if old_pos + more <= Sys.max_string_length
    then new_len := Sys.max_string_length
    else failwith "Buffer.add: cannot grow buffer"
  end;
  let new_buffer = Bytes.create !new_len in
  (* PR#6148: let's keep using [blit] rather than [unsafe_blit] in
     this tricky function that is slow anyway. *)
  Bytes.blit b.buffer 0 new_buffer 0 b.position;
  b.buffer <- new_buffer;
  b.length <- !new_len;
  assert (b.position + more <= b.length);
  assert (old_pos + more <= b.length);
  ()
  (* Note: there are various situations (preemptive threads, signals and
     gc finalizers) where OCaml code may be run asynchronously; in
     particular, there may be a race with another user of [b], changing
     its mutable fields in the middle of the [resize] call. The Buffer
     module does not provide any correctness guarantee if that happens,
     but we must still ensure that the datastructure invariants hold for
     memory-safety -- as we plan to use [unsafe_{get,set}].

     There are two potential allocation points in this function,
     [ref] and [Bytes.create], but all reads and writes to the fields
     of [b] happen before both of them or after both of them.

     We therefore assume that [b.position] may change at these allocations,
     and check that the [b.position + more <= b.length] postcondition
     holds for both values of [b.position], before or after the function
     is called. More precisely, the following invariants must hold if the
     function returns correctly, in addition to the usual buffer invariants:
     - [old(b.position) + more <= new(b.length)]
     - [new(b.position) + more <= new(b.length)]
     - [old(b.length) <= new(b.length)]

     Note: [b.position + more <= old(b.length)] does *not*
     hold in general, as it is precisely the case where you need
     to call [resize] to increase [b.length].

     Note: [assert] above does not mean that we know the conditions
     always hold, but that the function may return correctly
     only if they hold.

     Note: the other functions in this module does not need
     to be checked with this level of scrutiny, given that they
     read/write the buffer immediately after checking that
     [b.position + more <= b.length] hold or calling [resize].
  *)

let add_char b c =
  let pos = b.position in
  if pos >= b.length then resize b 1;
  Bytes.unsafe_set b.buffer pos c;
  b.position <- pos + 1

let uchar_utf_8_byte_length_max = 4
let uchar_utf_16_byte_length_max = 4

let rec add_utf_8_uchar b u =
  let pos = b.position in
  if pos >= b.length then resize b uchar_utf_8_byte_length_max;
  let n = Bytes.set_utf_8_uchar b.buffer pos u in
  if n = 0
  then (resize b uchar_utf_8_byte_length_max; add_utf_8_uchar b u)
  else (b.position <- pos + n)

let rec add_utf_16be_uchar b u =
  let pos = b.position in
  if pos >= b.length then resize b uchar_utf_16_byte_length_max;
  let n = Bytes.set_utf_16be_uchar b.buffer pos u in
  if n = 0
  then (resize b uchar_utf_16_byte_length_max; add_utf_16be_uchar b u)
  else (b.position <- pos + n)

let rec add_utf_16le_uchar b u =
  let pos = b.position in
  if pos >= b.length then resize b uchar_utf_16_byte_length_max;
  let n = Bytes.set_utf_16le_uchar b.buffer pos u in
  if n = 0
  then (resize b uchar_utf_16_byte_length_max; add_utf_16le_uchar b u)
  else (b.position <- pos + n)

let add_substring b s offset len =
  if offset < 0 || len < 0 || offset > String.length s - len
  then invalid_arg "Buffer.add_substring/add_subbytes";
  let new_position = b.position + len in
  if new_position > b.length then resize b len;
  Bytes.unsafe_blit_string s offset b.buffer b.position len;
  b.position <- new_position

let add_subbytes b s offset len =
  add_substring b (Bytes.unsafe_to_string s) offset len

let add_string b s =
  let len = String.length s in
  let new_position = b.position + len in
  if new_position > b.length then resize b len;
  Bytes.unsafe_blit_string s 0 b.buffer b.position len;
  b.position <- new_position

let add_bytes b s = add_string b (Bytes.unsafe_to_string s)

let add_buffer b bs =
  add_subbytes b bs.buffer 0 bs.position

(* this (private) function could move into the standard library *)
let really_input_up_to ic buf ofs len =
  let rec loop ic buf ~already_read ~ofs ~to_read =
    if to_read = 0 then already_read
    else begin
      let r = input ic buf ofs to_read in
      if r = 0 then already_read
      else begin
        let already_read = already_read + r in
        let ofs = ofs + r in
        let to_read = to_read - r in
        loop ic buf ~already_read ~ofs ~to_read
      end
    end
  in loop ic buf ~already_read:0 ~ofs ~to_read:len


let unsafe_add_channel_up_to b ic len =
  if b.position + len > b.length then resize b len;
  let n = really_input_up_to ic b.buffer b.position len in
  (* The assertion below may fail in weird scenario where
     threaded/finalizer code, run asynchronously during the
     [really_input_up_to] call, races on the buffer; we don't ensure
     correctness in this case, but need to preserve the invariants for
     memory-safety (see discussion of [resize]). *)
  assert (b.position + n <= b.length);
  b.position <- b.position + n;
  n

let add_channel b ic len =
  if len < 0 || len > Sys.max_string_length then   (* PR#5004 *)
    invalid_arg "Buffer.add_channel";
  let n = unsafe_add_channel_up_to b ic len in
  (* It is intentional that a consumer catching End_of_file
     will see the data written (see #6719, #7136). *)
  if n < len then raise End_of_file;
  ()

let output_buffer oc b =
  output oc b.buffer 0 b.position

let closing = function
  | '(' -> ')'
  | '{' -> '}'
  | _ -> assert false

(* opening and closing: open and close characters, typically ( and )
   k: balance of opening and closing chars
   s: the string where we are searching
   start: the index where we start the search. *)
let advance_to_closing opening closing k s start =
  let rec advance k i lim =
    if i >= lim then raise Not_found else
    if s.[i] = opening then advance (k + 1) (i + 1) lim else
    if s.[i] = closing then
      if k = 0 then i else advance (k - 1) (i + 1) lim
    else advance k (i + 1) lim in
  advance k start (String.length s)

let advance_to_non_alpha s start =
  let rec advance i lim =
    if i >= lim then lim else
    match s.[i] with
    | 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' -> advance (i + 1) lim
    | _ -> i in
  advance start (String.length s)

(* We are just at the beginning of an ident in s, starting at start. *)
let find_ident s start lim =
  if start >= lim then raise Not_found else
  match s.[start] with
  (* Parenthesized ident ? *)
  | '(' | '{' as c ->
     let new_start = start + 1 in
     let stop = advance_to_closing c (closing c) 0 s new_start in
     String.sub s new_start (stop - start - 1), stop + 1
  (* Regular ident *)
  | _ ->
     let stop = advance_to_non_alpha s (start + 1) in
     String.sub s start (stop - start), stop

(* Substitute $ident, $(ident), or \${ident} in s,
    according to the function mapping f. *)
let add_substitute b f s =
  let lim = String.length s in
  let rec subst previous i =
    if i < lim then begin
      match s.[i] with
      | '$' as current when previous = '\\\\' ->
         add_char b current;
         subst ' ' (i + 1)
      | '$' ->
         let j = i + 1 in
         let ident, next_i = find_ident s j lim in
         add_string b (f ident);
         subst ' ' next_i
      | current when previous == '\\\\' ->
         add_char b '\\\\';
         add_char b current;
         subst ' ' (i + 1)
      | '\\\\' as current ->
         subst current (i + 1)
      | current ->
         add_char b current;
         subst current (i + 1)
    end else
    if previous = '\\\\' then add_char b previous in
  subst ' ' 0

let truncate b len =
    if len < 0 || len > length b then
      invalid_arg "Buffer.truncate"
    else
      b.position <- len

(** {1 Iterators} *)

let to_seq b =
  let rec aux i () =
    (* Note that b.position is not a constant and cannot be lifted out of aux *)
    if i >= b.position then Seq.Nil
    else
      let x = Bytes.unsafe_get b.buffer i in
      Seq.Cons (x, aux (i+1))
  in
  aux 0

let to_seqi b =
  let rec aux i () =
    (* Note that b.position is not a constant and cannot be lifted out of aux *)
    if i >= b.position then Seq.Nil
    else
      let x = Bytes.unsafe_get b.buffer i in
      Seq.Cons ((i,x), aux (i+1))
  in
  aux 0

let add_seq b seq = Seq.iter (add_char b) seq

let of_seq i =
  let b = create 32 in
  add_seq b i;
  b

(** {6 Binary encoding of integers} *)

external unsafe_set_int8 : bytes -> int -> int -> unit = "%bytes_unsafe_set"
external unsafe_set_int16 : bytes -> int -> int -> unit = "%caml_bytes_set16u"
external unsafe_set_int32 : bytes -> int -> int32 -> unit = "%caml_bytes_set32u"
external unsafe_set_int64 : bytes -> int -> int64 -> unit = "%caml_bytes_set64u"
external swap16 : int -> int = "%bswap16"
external swap32 : int32 -> int32 = "%bswap_int32"
external swap64 : int64 -> int64 = "%bswap_int64"


let add_int8 b x =
  let new_position = b.position + 1 in
  if new_position > b.length then resize b 1;
  unsafe_set_int8 b.buffer b.position x;
  b.position <- new_position

let add_int16_ne b x =
  let new_position = b.position + 2 in
  if new_position > b.length then resize b 2;
  unsafe_set_int16 b.buffer b.position x;
  b.position <- new_position

let add_int32_ne b x =
  let new_position = b.position + 4 in
  if new_position > b.length then resize b 4;
  unsafe_set_int32 b.buffer b.position x;
  b.position <- new_position

let add_int64_ne b x =
  let new_position = b.position + 8 in
  if new_position > b.length then resize b 8;
  unsafe_set_int64 b.buffer b.position x;
  b.position <- new_position

let add_int16_le b x =
  add_int16_ne b (if Sys.big_endian then swap16 x else x)

let add_int16_be b x =
  add_int16_ne b (if Sys.big_endian then x else swap16 x)

let add_int32_le b x =
  add_int32_ne b (if Sys.big_endian then swap32 x else x)

let add_int32_be b x =
  add_int32_ne b (if Sys.big_endian then x else swap32 x)

let add_int64_le b x =
  add_int64_ne b (if Sys.big_endian then swap64 x else x)

let add_int64_be b x =
  add_int64_ne b (if Sys.big_endian then x else swap64 x)

let add_uint8 = add_int8
let add_uint16_ne = add_int16_ne
let add_uint16_le = add_int16_le
let add_uint16_be = add_int16_be

(* 1 *)
let foo =
if u then let x = v1 in v2
else let y = w1 in w2

(* 2 *)
let foo =
if u then let x = v1 in v2
else
  let y = w1 in
  w2

(* 3 *)
let foo =
if u then
  let x = v1 in
  v2
else let y = w1 in w2

(* 4 *)
let foo =
if u then
  let x = v1 in
  v2
else
  let y = w1 in
  w2

(* Test of a first-class module. *)

module type FOO = sig val foo : string end
let create foo : (module FOO) = (module struct let foo = foo end)
module Foo = (val create "Issue #106")

let _ =
  let f x l = x::l in
  f 120 [130]

let topological_sort deps =
  let to_graph _ deps graph = (deps.file, MSet.elements deps.deps)::graph in
  let graph = Hashtbl.fold to_graph deps [] in
  let rec explore path visited node =
    if List.mem node path then
      raise @@ Dep_error (CircularDependencies (node, path));
    if List.mem node visited then visited
    else
      let edges = try
          List.assoc node graph
        with
          Not_found ->
            if !ignore then []
            else
              raise
                @@ Files_legacy.Files_error (ObjectFileNotFound (mk_mident node))
                | _ -> assert false
      in node::List.fold_left (explore (node::path)) visited
        (List.map Files_legacy.get_file edges)
  in
  List.rev @@ List.fold_left (fun visited (n, _) -> explore [] visited n) [] graph

(* The even and odd functions assume that their argument is non-negative. *)
let rec odd = function
| 0 -> false
| y -> even (y - 1)

  and even y = if y = 0 then true else odd (y - 1)


module ListSetExtended = struct
  include ListSet
  let of_list lst = List.fold_right add lst empty
end

module My_types = struct
type nonrec t=t
type my_rec={my_bool: bool;}
end


module type Printer = sig
(** [print_list sep printer] returns a printer for ['a list] using [printer] as
    element printer and [sep] as separator between elements. *)
val print_list : string -> 'a printer -> 'a list printer
val print_name : name printer

val print_ident : ident printer
end

(* Let us declare an extensible variant. *)
type _ variant = ..

(* And extend it. *)
type _ variant +=
  | Basic : unit variant
  | PrettyPrinter : unit variant  (** Pretty print *)

(* Two times. *)
type _ variant += WithBuff : t variant

let add_multiline x =
  let res =
    x + x in
  res

let add_one_line x = let res = x + x in res

let add_two_lines x =
  let res = x + x in
  res

let add_three_lines x =
  let res = x + x
  in
  res

let add_as_fun_multiline = fun x ->
  x

let add_as_fun_one_line = fun x -> x

let sum_of_int n =
  let res = ref 0 in
  for i = 1 to n do res := !res + i; done

let sum_of_int_reversed n =
  let res = ref 0 in
  for i = n downto 1 do res := !res + i; done

let verbose_id = function
  | -1 -> -1
  | n -> n

let is_prime n =
  let no_divisor = ref true in
  let i = ref 1 in
  while !no_divisor && !i * !i < n do
    incr i;
    if n mod !i = 0
    then no_divisor := false;
  done;
  !no_divisor

let unbox_rec = function
  | Some My_types.{ my_bool } -> my_bool
  | _ -> false

let unbox_bool = function
  | Some true -> true
  | _ -> false

let is_some_letter = function
  | Some 'a'..'z' -> true
  | _ -> false

let is_some_some = function
  | Some Some _ -> true
  | _ -> false

let my_const :
  type a b. a: a -> b: b -> a =
  fun ~a ~b -> a

let my_id ~value = value

let into_list ~value = my_id ~value :: []

let long_function
  (long_argument_1 : int)
  (long_argument_2 : int)
  (long_argument_3 : int)
  (long_argument_4 : int) : unit =
  ()

let large_const =
  let val = 3 in
  fun
    (long_argument_1 : int)
    (long_argument_2 : int)
    (long_argument_3 : int)
    (long_argument_4 : int) : int ->
    val

let [a; _; _] = [1; 2;
  3]

let [|a; _; _|] = [|1; 2;
  3|]

let _ = (let x = 42 in
  x)

let _ =
  let foo =
    fun x -> x
  in
  foo

let _ =
  let foo =
    function true -> false | false -> true
  in
  foo

(* Showcase the usage of operator bindings *)
let greetings =
  let (let*) = Option.bind
  and (and*) a_opt b_opt =
    match (a_opt, b_opt) with
    | (Some a, Some b) -> Some (a, b)
    | _ -> None
  in
  let* msg1 =
    Option.map String.capitalize_ascii (Some "hello ")
  and* msg2 = Some "world"
  in
  Some (msg1 ^ msg2)

(* Some pattern-matching *)
let hd::_ = [1; 2; 3]

let Some message = Some "message"

let [1; snd] = [1; 2]

type a = int and
b = float

(* Messing around with quoted strings and curly brackets *)
type string_record = { my_string: string; }
let quoted_string =
  {|Hello|}
and quoted_string_multiline_with_id =
  {external|
World
{|!|}
|external}
let _ =
  {
    my_string = quoted_string ^ quoted_string_multiline_with_id
  }

(* Tags in pattern matching *)
type my_box = [\`Foo of int | \`Bar of int]
let unbox = function
  | \`Foo a | \`Bar a -> a

(* Type coercion *)
let _ = (\`Foo 4 :> [\`Foo of int])

(* function signature containing type variables *)
let my_const : 'a 'b. 'a -> 'b -> 'a = Fun.const

(* Showcase OOP *)
module Inner1 = struct
  class ['a] pushable =
    object (self)
      val mutable list = ([]: 'a list)

      method push x =
        list <- x::list
    end

  class virtual ['a] poppable =
    object (self)
      inherit ['a] pushable

      (* unsafe implementation *)
      method pop =
        let result::rest = list in
        list <- rest;
        Some result
    end
end

module Inner2 = struct
  class type ['a] stack =
    object
      inherit ['a] Inner1.poppable
    end

  class ['a] stack_impl : ['a] stack =
    object
      inherit ['a] Inner1.poppable as super

      (* safe implementation *)
      method pop =
        match list with
        | _::_ -> super#pop
        | _ -> None
    end
end

let (Some 2) =
  let my_stack = new Inner2.stack_impl in
  my_stack#push 1;
  my_stack#push 2;
  my_stack#pop

let obj_id (obj : < .. >) = obj

let obj_with_unit_id (obj : < nothing: unit; .. >) = obj

let obj_with_only_unit_id (obj : < nothing: unit >) = obj

(* Some modules and functors *)
module type T1 = sig
  type t = private int64
end

module type T2 = sig end

module M: T2 = struct end

module F (X: T1) (Y: T1 with type t := X.t) = struct
  module type S = sig
    type t = X.t

    val zero : t

    val succ : t -> t

    include T2
  end

  let zero = 0

  let succ n = n + 1

  include M
end

(* Showcase ppx usage *)
let _ =
  let lid = [%sedlex.regexp? R] in
  body

let _ = [%sedlex.regexp R]

let _ =
  [%sedlex match lexbuf with
    | R1 -> e1
    | Rn -> en
    | _  -> def
  ]

let _ = match%sedlex lexbuf with
  | R1 -> e1
  | Rn -> en
  | _  -> def

let x = foo;%lwt bar

let x =
  foo;%lwt bar;%lwt
  baz;%lwt qux

let x =
  foo
    bar;%lwt
  baz

let x = function
  | [%type: [%t? foo] option] ->
    bar

let _ =
  foo <- { slug; };
  bar

let _ = 12 [@deprecated "12 is deprecated, use 13 instead"]

let _ = "some string"
  [@@deprecated "assignment are deprecated, inline everything instead"]

[@@@deprecated "writing code is deprecated, use ai-generated code instead"]

type t =
  { verbose: int
  (** Verbosity level. *)
  ; loggers: string
  (** Loggers enabled. *)
  ; bflags: bool StrMap.t
  (** Boolean flags. *)
  }

let _ =
  { verbose = 0
  ; loggers = "foo"
  ; bflags = StrMap.empty
  }

type t = {
  foo: bool [@default false];
  bar: int
}

type t = {
  foo: bool;
  bar: int [@default 0]
}

type t = {
  foo: bool;
  bar: int [@default 0] (* comment *);
}

(* A merry mess of ppx tags, comments, and misplaced semicolons *)
type t = {
  bar: float;
  foo: bool [@default false] (* a comment *) [@other tag] (* and another one *)
     [@and again] (* and another one *) [@and again] (* and a last one *);
}
type t = {
  bar: float;
  foo: bool [@default false] (* a comment *) [@other tag] (* and another one *)
     [@and again] (* and another one *) [@and again] (* and a last one *)
}

type message = {
  raw_level : int32;
  message_counter : Z.t; [@printer Z.pp_print]
  payload : bytes;
}

let _ = {
  bar = 0.0;
  foo = True
  [@some tag]
  [@some other_tag]
}

type controller =
  | C : Slug.t -> controller

let _ =
  let open Printf in
  sprintf "hello world"

let foo : #x y z = bar

(* Playing with nested structures *)
let _ =
  ( 1, 2
  , 3
  , 4
  )

let _ =
  (1, 2, (3, 4),
  5, 6)

let x = foo || foo
  || bar || bar

let x = foo; foo;
  bar; bar

let _ = {
  foo = let bar = baz in bar
}

(* Open and let open *)
open Foo
open Bar

let _ =
  let open Baz in
  ()

(* let module *)
let x =
  let module IMap = Map.Make(Int) in
  IMap.empty

(* Multi-line functor signatures *)
module Lift
  (Credit: module type of CreditSignature)
  (Dance: module type of DanceSignature)
  (Tune: module type of TuneSignature)
  (Version: module type of VersionSignature)
= struct
  let foo = x
end

module MOption:
  functor (A: SERIALISABLE) -> SERIALISABLE with
  type t = A.t option

module MUnit: SERIALISABLE with
  type t = unit

(* Ensure labelled arguments are correctly spaced *)
let _ =
  foo ~arg :: []

(* Various spacing corner cases *)
type query = (string * string list) list
type x = ('any Slug.t -> bool) -> float
let id (type s) (x : s) : s = x
type foo = { a : 'a. ('a, mandatory) arg -> 'a; }
type foo = (int, int) result

(* exotic types *)
type (+'meth, 'prefix, 'params, 'query, 'input, 'output) service =
  ('meth, 'prefix, 'params, 'query, 'input, 'output, error) raw
  constraint 'meth = [< meth]

(* Indentation of multi-line types in PPX syntax *)
let h =
  [%madcast: float ->
    bool]

(* Indentation of function cases in PPX syntax *)
let x =
  [%expr function
    | false -> 0.
    | true -> 1.]

(* New line for structures in module definitions *)
module MFloat : SERIALISABLE
  with type t = float =
struct
  type t = float [@@deriving yojson]
  let _key = "float"
end

module Make (R : sig end)
  (S : sig end) (T : sig end)

(* Showcase usage of line number directive. Line breaks could be improved. *)
module Foo = struct
  val bar

# 1 "v1/pervasives.mli"
end

module MyTime = struct include Time end

(* Nested match cases *)
let foo = function
  | x -> (
    try foo with _ -> None )

let _ = try%foo
    bar
  with
    | Not_found -> baz
    | _ -> qux

let f = function
  | None -> ()
  | Some x ->
    (match x with None -> () | Some _ -> ())

let foo = function
  | Some _ ->
    (function true -> false | false -> true)
  | None ->
    (function true -> true | false -> false)

(* set expressions *)
let _ =
  x <-
    if foo then
      bar
    else
      baz

(* various test cases for "|" rules *)
let not = function
  true -> false
  | false -> true

let not x = match x with
  | false -> true
  | true -> false

let not =
  function | true -> false | false -> true

let not = function true -> false | false -> true

let not x = match x with | true -> false | false -> true

exception MyException of string
`,
  },
  "rust": {
    query: `; Configuration
(#language! rust)
(#indent! "    ")

; Sometimes we want to indicate that certain parts of our source text should
; not be formatted, but taken as is. We use the leaf capture name to inform the
; tool of this.
(string_literal) @leaf

; Allow blank line before
[
  (attribute_item)
  (block_comment)
  (call_expression)
  (enum_item)
  (enum_variant)
  (field_declaration)
  (function_item)
  (impl_item)
  (let_declaration)
  (line_comment)
  (mod_item)
  (struct_item)
  (type_item)
  (use_declaration)
] @allow_blank_line_before

; Surround spaces
[
  "as"
  "const"
  "else"
  "extern"
  "fn"
  "for"
  "if"
  "let"
  (mutable_specifier)
  (scoped_use_list)
  "struct"
  "type"
  "unsafe"
  (visibility_modifier)
  "="
  "=="
  "-"
  "+"
  "->"
] @prepend_space @append_space

; Append spaces
[
  ":"
] @append_space

; Input softlines before and after all comments. This means that the input
; decides if a comment should have line breaks before or after. A line comment
; always ends with a line break.
[
  (block_comment)
  (line_comment)
] @prepend_input_softline

; Input softline after block comments unless followed by comma or semicolon, as
; they are always put directly after.
(
  (block_comment) @append_input_softline
  .
  ["," ";"]* @do_nothing
)

; Append line breaks. If there is a comment following, we don't add anything,
; because the input softlines and spaces above will already have sorted out the
; formatting.
(
  [
    (attribute_item)
    (enum_item)
    (extern_crate_declaration)
    (function_item)
    (impl_item)
    (let_declaration)
    (mod_item)
    (struct_item)
    (type_item)
    (use_declaration)
  ] @append_hardline
  .
  [
    (block_comment)
    (line_comment)
  ]* @do_nothing
)

(line_comment) @append_hardline

; Append softlines, unless followed by comments.
(
  [
    ","
    ";"
  ] @append_spaced_softline
  .
  [(block_comment) (line_comment)]* @do_nothing
)

; Prepend softlines before dots
(_
  "." @prepend_empty_softline
)

; enum
(enum_item
  (type_identifier) @prepend_space
)

; This patterns is duplicated for all nodes that can contain curly braces.
; Hoping to be able to generalise them like this:
; (_
;   .
;   "{" @prepend_space
;   (#for! block declaration_list enum_variant_list field_declaration_list)
; )
; Perhaps even the built in #match! can do this

(enum_variant_list
  .
  "{" @prepend_space
)

(enum_variant_list
  .
  "{" @append_spaced_softline @append_indent_start
  _
  "}" @prepend_spaced_softline @prepend_indent_end
  .
)

; field
(field_declaration_list
  .
  "{" @prepend_space
)

(field_declaration_list
  .
  "{" @append_spaced_softline @append_indent_start
  _
  "}" @prepend_spaced_softline @prepend_indent_end
  .
)

; fn
(function_item
  (identifier) @prepend_space
)

(block
  .
  "{" @prepend_space
)

(block
  .
  "{" @append_spaced_softline @append_indent_start
  _
  "}" @prepend_spaced_softline @prepend_indent_end
  .
)

; impl
(impl_item
  (type_identifier) @prepend_space
)

(declaration_list
  .
  "{" @prepend_space
)

; PhantomData<&'a ()>
(_
  (lifetime) @append_space
  [(array_type) (generic_type) (primitive_type) (unit_type)]
)
`,
    input: `unsafe impl Send for Language {}
unsafe impl Sync for Language {}

/// Sample doc comment
pub fn node_kind_for_id(&self, id: u16) -> &'static str {
    unsafe { CStr::from_ptr(ffi::ts_language_symbol_name(self.0, id)) }
    .to_str()
    .unwrap();
    "foo"
}

// Comments
// at the beginning.

// More comments.

enum OneLine { Leaf { content: String, /* comment */ id: usize /* another comment */, size: usize, }, Hardline { content: String, id: usize, }, Space, } // End of line comment

enum ExpandEnum {
    Leaf { content: String, /* Comment between fields. */ id: usize, size: usize, },
    Hardline { content: String, id: usize, },
    Space,
}
enum NoFinalComma {
    Space,
}

enum ExpandTwoLevels {
    Leaf {
        content: String,
         //   Comment after field declaration in enum variant.
        id: usize,

        size: usize,
    },
    Hardline { content: String, id: usize, },

    // comment between enum items
    Space,
}

enum Mode1 {
    Open, // open
    Closed, // closed
    Either, // just leaving the current mode unchanged
}

enum Mode2 {
    Open,
    /// Doc comment
    /// about Closed.
    Closed,
    // just leaving the current mode unchanged
    Either,
}

enum Mode3 {
    Open,
    Closed,
    Either, /* just leaving the current mode unchanged */
}

enum Mode4 {
    Open,
    Closed,
    /* just leaving the current mode unchanged */
    Either,
}

enum Mode5 {
    Open,
    Closed,
    // just leaving the current
    // mode unchanged
    Either,
}

enum Mode6 {
    Open,
    Closed,
    /* just leaving the current
       mode unchanged */
    Either,
}
`,
  },
  "toml": {
    query: `; Configuration
(#language! toml)

; Sometimes we want to indicate that certain parts of our source text should
; not be formatted, but taken as is. We use the leaf capture name to inform the
; tool of this.
(string) @leaf

; Allow blank line before
[
  (comment)
  (table)
  (table_array_element)
  (pair)
] @allow_blank_line_before

; Append line breaks
[
  (comment)
] @append_hardline

(table
  (pair) @append_hardline
)

(table_array_element
  (pair) @append_hardline
)

(table
  [(bare_key) (dotted_key)]
  .
  "]" @append_hardline
)

(table_array_element
  [(bare_key) (dotted_key)]
  .
  "]]" @append_hardline
)

; Surround spaces
[
  "="
  "{"
  "}"
] @prepend_space @append_space

; Input softlines before all comments. This means that the input decides if a
; comment should have line breaks in front of it.
(comment) @prepend_input_softline

; Softlines. These become either a space or a newline, depending on whether we
; format their node as single-line or multi-line.
[
  ","
] @append_spaced_softline

; Indent arrays. They will only be indented inmulti-line blocks.

(array
  "[" @append_spaced_softline @append_indent_start
)

(array
  "]" @prepend_spaced_softline @prepend_indent_end
)
`,
    input: `
[package]

name="topiary"
 description = "Takes a source file from stdin and outputs a version to stdout that is formatted according to the specified language."
version = "0.1.0"
edition = "2021"

[ dependencies ]
# For now we just load the tree-sitter language parsers statically. 
# Eventually we will want to dynamically load them, like Helix does.
clap = {version="3.2",features=["derive"]}
env_logger = "0.9"
itertools = "0.10"
log = "0.4"
pretty = "0.11"
pretty_assertions = "1.3"
test-log = "0.2"
tree-sitter = "0.20"
tree-sitter-json = "0.19"
tree-sitter-rust = "0.20"


# Needs a version > 0.19
tree-sitter-ocaml = { git = "https://github.com/tree-sitter/tree-sitter-ocaml" }


[dev-dependencies]
criterion = "0.4"

[[ bench ]]
name = "benchmark"
harness = false

# This is a TOML document.

title = "TOML Example"

[owner]
name = "Tom Preston-Werner"
dob = 1979-05-27T07:32:00-08:00 # First class dates

[database]
server = "192.168.1.1"
ports = [ 8001, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

  # Indentation (tabs and/or spaces) is allowed but not required
  [servers.alpha]
  ip = "10.0.0.1"
  dc = "eqdc10"

  [servers.beta]
  ip = "10.0.0.2"
  dc = "eqdc10"

[clients]
data = [ ["gamma", "delta"], [1, 2] ]

# Line breaks are OK when inside arrays
hosts = [
  "alpha",
  "omega"
]

`,
  },
  "tree-sitter-query": {
    query: `; Configuration
(#language! tree-sitter-query)

; Sometimes we want to indicate that certain parts of our source text should
; not be formatted, but taken as is. We use the leaf capture name to inform the
; tool of this.
[
  (capture)
  (identifier)
  (string)
] @leaf

(comment) @prepend_input_softline @append_hardline @allow_blank_line_before

; Elements at top-level must be alone on their line. Blank lines are allowed
(program
  _ @allow_blank_line_before @prepend_hardline
)

; There is a large category of nodes that must be separated by spaces
(
  [
    (anonymous_node)
    (capture)
    (identifier)
    (grouping)
    (named_node)
    (parameters)
    (quantifier)
    ":"
    "."
    ")"
    "]"
  ] @append_space
  .
  [")" "]" ":"]? @do_nothing
  .
  [
    (anonymous_node)
    (capture)
    (grouping)
    (named_node)
    "."
    "("
    "["
    "_"
  ]
)
(anonymous_node
  (capture) @prepend_space
)

; The grammar always includes a (parameters) child node under
; (predicate), even when there are none. Topiary will deal with the
; zero-byte nodes, so we just need to set the spacing correctly.
(predicate
  (parameters) @prepend_space
)

; Line breaks and indentation in multi-line lists and nodes
(list
  "[" @append_indent_start @append_empty_softline
  "]" @prepend_indent_end @prepend_empty_softline
)

(grouping
  "(" @append_indent_start @append_empty_softline
  ")" @prepend_indent_end @prepend_empty_softline
)

(named_node
  "("
  .
  [
    (identifier)
    "_"
  ] @append_indent_start @append_empty_softline
  ")" @prepend_indent_end @prepend_empty_softline
)

(
  [
    (anonymous_node)
    (field_definition)
    (list)
    (named_node)
    (predicate)
    "."
  ] @append_spaced_softline
  .
  [
    (anonymous_node)
    (field_definition)
    (list)
    (named_node)
    (predicate)
    "."
  ]
)
`,
    input: `; Configuration
(#language! ocaml)

; This query file is used to format trees produced by two different grammars:
; - the grammar for OCaml interface files \`tree_sitter_ocaml::language_ocaml_interface()\`
; - the grammar for OCaml implementation files \`tree_sitter_ocaml::language_ocaml()\`

; On certain cases, some files may correctly parse with both grammars, but produce
; different syntax trees. We want those files to be formatted the same way,
; independently of the grammar used to parse them.

; To ensure this property, we introduce equivalence classes on syntax node types.
; Simply put, if two node types are in the same equivalence class, then they must
; appear in the same queries.

; If you add or modify a query containing a node type in one of the equivalence classes,
; please make sure to add or modify the corresponding queries for all other node types
; in the same equivalence class.

; The equivalence classes are the following:
; - include_module, include_module_type
; - module_path, extended_module_path, module_type_path
; - module_name, module_type_name

; Sometimes we want to indicate that certain parts of our source text should
; not be formatted, but taken as is. We use the leaf capture name to inform the
; tool of this.
(
  [
    (character)
    (quoted_string)
    (signed_number)
    (string)
  ]
) @leaf

; line number directives must be alone on their line, and can't be indented
(line_number_directive) @single_line_no_indent

; Allow blank line before
[
  (class_definition)
  (class_type_definition)
  (comment)
  (exception_definition)
  (external)
  (floating_attribute)
  ; equivalence class
  [
    (include_module)
    (include_module_type)
  ]
  (inheritance_definition)
  (inheritance_specification)
  (instance_variable_definition)
  (method_definition)
  (module_definition)
  (module_type_definition)
  (open_module)
  (type_definition)
  (value_definition)
  (value_specification)
] @allow_blank_line_before

; In a definition including several mutually recursive functions,
; one can skip a line before each of them.
(value_definition
  "and" @allow_blank_line_before
)
(value_definition
  (and_operator) @allow_blank_line_before
)

; Append line breaks. If there is a comment following, we don't add anything,
; because the input softlines and spaces above will already have sorted out the
; formatting.
(
  [
    (exception_definition)
    (external)
    (module_definition)
    (module_type_definition)
    (type_definition)
  ] @append_hardline
  .
  "in"? @do_nothing
  .
  (comment)* @do_nothing
)
; Also append line breaks after open_module, except when it's
; preceded by "let", because in this case it's in a let_open_expression.
(
  "let"? @do_nothing
  .
  (open_module) @append_hardline
  .
  (comment)* @do_nothing
)

; Append line break after module include, except if it's alone in a single-lined struct
(
  [
    ; equivalence class
    (include_module)
    (include_module_type)
  ] @append_hardline
  .
  "end"? @do_nothing
)
(structure
  "struct"
  .
  [
    ; equivalence class
    (include_module)
    (include_module_type)
  ] @append_spaced_softline
  .
  "end"
)

; Consecutive definitions must be separated by line breaks
(
  [
    (value_definition)
    (value_specification)
  ] @append_hardline
  .
  [
    (exception_definition)
    (external)
    (module_definition)
    (module_type_definition)
    (open_module)
    (type_definition)
    (value_definition)
    (value_specification)
  ]
)

; Surround spaces
; A space is put after, and before (except just after an open parenthesis).
(
  [
    "and"
    "as"
    "assert"
    "class"
    "constraint"
    "downto"
    "else"
    "exception"
    "external"
    (floating_attribute)
    "for"
    "if"
    "in"
    "include"
    (infix_operator)
    "inherit"
    (item_attribute)
    "let"
    "match"
    "method"
    "module"
    (module_parameter)
    "mutable"
    "new"
    "nonrec"
    "object"
    "of"
    "open"
    (parameter)
    "private"
    "rec"
    "sig"
    "then"
    "to"
    "try"
    "type"
    "val"
    "virtual"
    "when"
    "while"
    "with"
    "*"
    "="
    "|"
    "||"
    "->"
    "<-"
    "{"
    ":"
    ";"
    "+="
    ":="
    ":>"
    "::"
    "[>"
    "[<"
  ] @append_space
  .
  "%"? @do_nothing
)

; Those keywords are not expected to come right after an open parenthesis.
[
    "as"
    "constraint"
    "do"
    "done"
    "downto"
    "else"
    "in"
    "nonrec"
    "of"
    "rec"
    "then"
    "to"
    "virtual"
    "when"
    "with"
    "|"
    "->"
    "<-"
    "+="
    ":="
    ":>"
    "::"
] @prepend_space

; let-like and and-like operators are only followed by a closing parenthesis
; during their definition, in which case no space must be appended.
; space must be appended otherwise
(
  (and_operator) @append_space
  .
  ")"* @do_nothing
)
(
  (let_operator) @append_space
  .
  ")"* @do_nothing
)

; For those queries, we should not have multiple queries,
; however, due to a known bug in tree-sitter queries
; https://github.com/tree-sitter/tree-sitter/issues/1811
; using an alternative after the starred parenthesis does not work as intented.
;
(
  "("* @do_nothing
  .
  "assert" @prepend_space
)
(
  "("* @do_nothing
  .
  (attribute) @prepend_space
)
(
  "("* @do_nothing
  .
  "begin" @prepend_space
)
(
  "("* @do_nothing
  .
  "class" @prepend_space
)
(
  "("* @do_nothing
  .
  "exception" @prepend_space
)
(
  "("* @do_nothing
  .
  "external" @prepend_space
)
(
  "("* @do_nothing
  .
  (floating_attribute) @prepend_space
)
(
  "("* @do_nothing
  .
  "for" @prepend_space
)
(
  "("* @do_nothing
  .
  "include" @prepend_space
)
(
  "("* @do_nothing
  .
  (infix_operator) @prepend_space
)
(
  "("* @do_nothing
  .
  "inherit" @prepend_space
)
(
  "("* @do_nothing
  .
  (item_attribute) @prepend_space
)
(
  "("* @do_nothing
  .
  "let" @prepend_space
)
(
  "("* @do_nothing
  .
  "method" @prepend_space
)
(
  "("* @do_nothing
  .
  "module" @prepend_space
)
(
  "("* @do_nothing
  .
  (module_parameter) @prepend_space
)
(
  "("* @do_nothing
  .
  "mutable" @prepend_space
)
(
  "("* @do_nothing
  .
  "new" @prepend_space
)
(
  "("* @do_nothing
  .
  "object" @prepend_space
)
(
  "("* @do_nothing
  .
  "open" @prepend_space
)
(
  "("* @do_nothing
  .
  (parameter) @prepend_space
)
(
  "("* @do_nothing
  .
  "private" @prepend_space
)
(
  "("* @do_nothing
  .
  "sig" @prepend_space
)
(
  "("* @do_nothing
  .
  "try" @prepend_space
)
(
  "("* @do_nothing
  .
  "type" @prepend_space
)
(
  "("* @do_nothing
  .
  "val" @prepend_space
)
(
  "("* @do_nothing
  .
  "while" @prepend_space
)
(
  "("* @do_nothing
  .
  "*" @prepend_space
)
(
  "("* @do_nothing
  .
  "=" @prepend_space
)
(
  "("* @do_nothing
  .
  "||" @prepend_space
)
(
  "("* @do_nothing
  .
  "}" @prepend_space
)

; Put a space after commas, except the last one.
(
  "," @append_space
  .
  (_)
)

; Put a space after the dot in polymorphic function types
;
; let my_const :
;   type a b. a: a -> b: b -> a =
;   fun ~a ~b -> a
(polymorphic_type
  "." @append_space
)

; Certain elements must be separated by spaces.
(
  [
    (boolean)
    (character)
    (class_path)
    (class_type_path)
    (constructed_type)
    (constructor_path)
    (extension)
    (field_get_expression)
    (hash_type)
    (labeled_argument)
    ; equivalence class
    [
      (extended_module_path)
      (module_path)
      (module_type_path)
    ]
    (number)
    (parenthesized_expression)
    (parenthesized_pattern)
    (polymorphic_variant_type)
    (quoted_string)
    (string)
    (tag)
    (type_constructor)
    (type_constructor_path)
    (typed_expression)
    (type_variable)
    (value_name)
    (value_path)
    (value_pattern)
    ")"
    "]"
  ] @append_space
  .
  [
    ; Don't add any space just before these.
    ","
    ";"
    "."
    ".."
    ")"
    "]"
  ]* @do_nothing
  .
  [
    (abstract_type)
    (boolean)
    (character)
    (class_name)
    (class_path)
    (class_type_name)
    (class_type_path)
    (constructed_type)
    (constructor_path)
    (constructor_pattern)
    (field_get_expression)
    (local_open_pattern)
    (labeled_argument)
    ; equivalence class
    [
      (extended_module_path)
      (module_path)
      (module_type_path)
    ]
    (number)
    (parenthesized_expression)
    (parenthesized_pattern)
    (polymorphic_variant_type)
    (prefix_expression)
    (quoted_string)
    (range_pattern)
    (string)
    (tag)
    (type_constructor)
    (type_constructor_path)
    (type_variable)
    (typed_expression)
    (value_name)
    (value_path)
    (value_pattern)
    "("
    "{"
  ]
)

; When one uses a language extension, we always put a space after the extension name,
; if this name ends by the '?' or ':' token, the space comes after it.
;
(
  (attribute_id) @append_space
  .
  (attribute_payload
    [
      "?"
      ":"
    ]
  )* @do_nothing
)
(attribute_payload
  [
    "?"
    ":"
  ] @append_space
)


; Some kinds of colons should have a space in front.
(
  [
    (constructor_name)
    (fun_expression)
    (parenthesized_expression)
    (value_name)
    (value_pattern)
  ] @append_space
  .
  ":"
)

; Keep spacing between pointy brackets when used in object types.
;
; This is syntactically correct:
;   let obj_id (obj : < .. >) = obj
; This is not:
;   let obj_id (obj : <..>) = obj
(object_type
  "<" @append_space
  ">" @prepend_space
)

; Softlines. These become either a space or a newline, depending on whether we
; format their node as single-line or multi-line. If there is a comment
; following, we don't add anything, because they will have their own line break
; processing applied to them.
;
; If those keywords are followed by a ppx extension,
; the soft linebreak comes after it.
(
  [
    "begin"
    "do"
    "in"
    "of"
    "struct"
    "then"
    "with"
    "{"
    ";"
  ] @append_spaced_softline
  .
  [
    (attribute)
    (comment)
    "%"
  ]* @do_nothing
)

(
  [
    "begin"
    "do"
    "in"
    "of"
    "struct"
    "then"
    "with"
    "{"
    ";"
  ]
  .
  "%"
  .
  (attribute_id) @append_spaced_softline
  .
  (comment)* @do_nothing
)

(type_binding
  (type_constraint) @prepend_spaced_softline
)

; only add softlines after "else" if it's not part of an "else if" construction
(
  "else" @append_spaced_softline
  .
  [
    (comment)
    (if_expression)
    "%"
  ]? @do_nothing
)

(
  "else"
  .
  "%"
  .
  (attribute_id) @append_spaced_softline
  .
  [
    (comment)
    (if_expression)
  ]? @do_nothing
)

; ":" must not always be followed by a softline, we explicitly enumerate
; the contexts where it must happen
(value_specification
  ":" @append_spaced_softline
)
(module_binding
  ":" @append_input_softline
)
(field_declaration
  ":" @append_spaced_softline
)
(typed_label
  ":" @append_spaced_softline
)
(constructor_declaration
  ":" @append_spaced_softline
)

; "->" must not always be followed by a softline, we explicitly enumerate
; the contexts where it must happen
(fun_expression
  "->" @append_spaced_softline
)
(match_case
  "->" @append_spaced_softline
)
(constructor_declaration
  "->" @append_spaced_softline
)

; Always put softlines before these:
[
  "and"
  "done"
  "end"
  (else_clause)
  (infix_operator)
  (item_attribute)
  "*"
  "|"
  "}"
] @prepend_spaced_softline

[
  (match_expression)
] @prepend_empty_softline

; Softline before the first match case
;
; let type_constant = function
;   Const_int _ -> instance Predef.type_int
;   | Const_char _ -> instance Predef.type_char
;
(
  "|"* @do_nothing
  .
  (match_case) @prepend_spaced_softline
)

; Multi-line definitions must have a linebreak after "=" and before "in":
;
; let a =
;   expression
;   in
;   expression
;
(
  (value_definition
    (_) @append_spaced_softline
    .
  )
  .
  "in"
)
; There are special cases however. We do not want to break lines after "=" when writing
;
; let f = function
;   | Constructor -> expression
;
; or
;
; let f = fun x ->
;   expression
;
(let_binding
  "=" @append_spaced_softline
  .
  [
    (function_expression)
    (fun_expression)
  ]* @do_nothing
)

; We chose not to add a line break between \`=\` and the
; \`fun\` or \`function\` keywords, but in order to keep the multi-lined-ness
; we must add a softline after the arrow. We need custom scopes to do this,
; since the node which contains the arrow may be single-line.
;
; This turns
;
; let foo =
;   fun x -> x
; in
; bar
;
; into
;
; let foo = fun x ->
;   x
; in
; bar
(let_binding
  "=" @begin_scope
  .
  (fun_expression
    "->" @append_spaced_scoped_softline
  ) @end_scope
  (#scope_id! "fun_definition")
)

; The same as above holds for single-line \`function\`.
;
; This turns
; let foo =
;   function true -> false | false -> true
; in
; bar
;
; into
;
; let foo = function
;   true -> false
;   | false -> true
; in
; bar
(let_binding
  "=" @begin_scope
  .
  (function_expression
    "function" @append_spaced_scoped_softline
  ) @end_scope
  (#scope_id! "function_definition")
)
(parenthesized_expression
  (function_expression) @begin_scope @end_scope
  (#scope_id! "function_definition")
)
(function_expression
  "|"* @do_nothing
  .
  (match_case) @prepend_spaced_scoped_softline
  (#scope_id! "function_definition")
)
(function_expression
  "|"* @prepend_spaced_scoped_softline
  .
  (match_case)
  (#scope_id! "function_definition")
)

(value_definition
  (and_operator) @prepend_spaced_softline
)

; There is a large class of terms which should be separated from "=" by a soft line break.
(
  "=" @append_spaced_softline
  .
  [
    (application_expression)
    (class_body_type)
    (constructed_type)
    (if_expression)
    (function_type)
    (let_expression)
    (object_expression)
    (product_expression)
    (record_expression)
    (sequence_expression)
    (set_expression)
    (typed_expression)
    (value_path)
    (variant_declaration)
  ]
)

; In module signature, each symbol declaration is separated by a softline.
;
; module type Name = sig
;   val function1 : type1
;   val function2 : type2
;  end
;
(signature
  "sig" @append_spaced_softline
  [
    (value_specification)
    (type_definition)
    ; equivalence class
    [
      (include_module)
      (include_module_type)
    ]
  ] @append_spaced_softline
)

; In class definitions and class type definitions, each declaration is separated
; by a softline.

; class foo =
;   object
;     inherit bar
;     val baz = None
;     method qux = None
;   end
;
(object_expression
  "object"
  [
    (inheritance_definition)
    (instance_variable_definition)
    (method_definition)
  ] @append_spaced_softline @prepend_spaced_softline
)

(class_body_type
  "object"
  [
    (inheritance_specification)
    (instance_variable_definition)
    (method_definition)
  ] @append_spaced_softline @prepend_spaced_softline
)

; Move semicolon delimiters just after field declarations,
; before any attributes and comments.
;
; type t =
;   { mutable position : int [@default 0] (* End-of-line comment *);
;   ...
;
; is turned into
;
; type t =
;   {
;     mutable position : int; [@default 0] (* End-of-line comment *)
;     ...
;
(record_declaration
  (field_declaration) @append_delimiter
  .
  [
    (comment)
    (attribute)
  ]*
  .
  ";" @delete
  (#delimiter! ";")
)

(record_declaration
  (field_declaration) @prepend_spaced_softline
)

; Allow multi-line attributes after field declaratioms, such as:
; type t = {
;   bar: float;
;   foo: bool
;     [@default false] (* a comment *)
;     [@other tag] (* and another one *)
;     [@and again] (* and another one *)
;     [@and again]; (* and a last one *)
; }
(record_declaration
  (#scope_id! "field_declaration")
  [
    (field_declaration)
    (attribute)
    (comment)
  ]? @end_scope
  .
  (field_declaration) @begin_scope
)
(record_declaration
  (#scope_id! "field_declaration")
  [
    (field_declaration)
    (attribute)
    (comment)
  ] @end_scope
  .
  "}"
)
(record_declaration
  (attribute) @prepend_indent_start @prepend_spaced_scoped_softline @append_indent_end
  (#scope_id! "field_declaration")
)

; Duplicate the same logic as above for record *expressions*
(record_expression
  (field_expression) @append_delimiter
  .
  [
    (comment)
    (attribute)
  ]*
  .
  ";" @delete
  (#delimiter! ";")
)

(record_expression
  (field_expression) @prepend_spaced_softline
)

(record_expression
  (#scope_id! "field_expression")
  [
    (field_expression)
    (attribute)
    (comment)
  ]? @end_scope
  .
  (field_expression) @begin_scope
)
(record_expression
  (#scope_id! "field_expression")
  [
    (field_expression)
    (attribute)
    (comment)
  ] @end_scope
  .
  "}"
)
(record_expression
  (attribute) @prepend_indent_start @prepend_spaced_scoped_softline @append_indent_end
  (#scope_id! "field_expression")
)

; Start an indented block after these
[
  "begin"
  "do"
  "object"
  "sig"
  "struct"
  "then"
] @append_indent_start

; "{" can be used to start quoted strings. Don't indent in that case
(
  "{" @append_indent_start
  .
  (quoted_string_content)* @do_nothing
)

; End the indented block before these
(
  [
    "done"
    "end"
  ] @prepend_indent_end
)

; "}" can be used to end quoted strings. Don't indent in that case
(
  (quoted_string_content)* @do_nothing
  .
  "}" @prepend_indent_end
)

; Only indent after "else" if it's not an "else if" construction
(
  (else_clause
    "else" @append_indent_start
    (if_expression)? @do_nothing
  ) @append_indent_end
)

; End the indented block after these
(
  (then_clause) @append_indent_end
)

; Make an indented block after ":" in typed expressions
;
; (fun _env _md -> assert false) :
;   Env.t -> Parsetree.module_expr -> Typedtree.module_expr * Shape.t
;
(typed_expression
  ":" @append_indent_start
  (_) @append_indent_end
  .
  ; just doing _ above doesn't work, because it matches the final named node as
  ; well as the final non-named node, causing double indentation.
)

(value_specification
  ":" @append_indent_start
  (_) @append_indent_end
  .
)

; Make an indented block after "=" in
; * class bindings
; * class_type bindings
; * instance variable definitions
; * method definitions
; * type bindings

(class_binding
  "=" @append_indent_start
  (_) @append_indent_end
)

(class_type_binding
  "=" @append_indent_start
  (_) @append_indent_end
)

(instance_variable_definition
  "=" @append_indent_start
  (_) @append_indent_end
)

(method_definition
  "=" @append_indent_start
  (_) @append_indent_end
)

; Don't indent for record types nor polymorphic variant types:
; they are already indented, and we don't process double indentation well enough
(type_binding
  [
    "="
    "+="
  ] @append_indent_start
  .
  [
    (constructed_type)
    (function_type)
    (hash_type)
    (object_type)
    (parenthesized_type)
    (tuple_type)
    (type_constructor_path)
    (type_variable)
    (variant_declaration)
  ] @append_indent_end
  .
  (type_constraint)? @do_nothing
)
(type_binding
  [
    "="
    "+="
  ] @append_indent_start
  .
  [
    (constructed_type)
    (function_type)
    (hash_type)
    (object_type)
    (parenthesized_type)
    (tuple_type)
    (type_constructor_path)
    (type_variable)
    (variant_declaration)
  ]
  .
  (type_constraint) @append_indent_end
)

; Make an indented block after "of" or ":" in constructor declarations
;
; | Expr_type_clash of
;   Errortrace.unification_error * type_forcing_context option
; | Pattern_type_clash :
;   Errortrace.unification_error * Parsetree.pattern_desc option -> error
;
(constructor_declaration
  [
    "of"
    ":"
  ] @append_indent_start
  (_) @append_indent_end
  .
)

; Make an indented block after the first term in a long if expression
;
; if len < 0
;  || srcoff < 0
;  || srcoff > src.position - len then
;
(if_expression
  (infix_expression
    .
    (_) @append_indent_start
    (_) @append_indent_end
    .
  )
)

; Make an indented block after match arrows.
;
; match lid with
; | Ldot(_, "false") ->
;   Boolean
;
(match_case
  "->" @append_indent_start
  (_) @append_indent_end
  .
)

; Make an indented block after constructor declaration arrows.
;
; Errortrace.unification_error * Parsetree.pattern_desc option ->
;   error
;
(constructor_declaration
  "->" @append_indent_start
  (_) @append_indent_end
  .
)

; Make an indented block where a function type arrow starts. Only for the root
; level, not for each arrow.
;
; (?used_slot:bool ref ->
;   Longident.t loc ->
;   Path.t * Env.t)
;
(constructed_type
  (function_type
    "->" @append_indent_start
    (_) @append_indent_end
    .
  )
)

; Make an indented block where a function/match starts in PPX syntax.
(extension
  "[%" @append_indent_start
  "]" @prepend_indent_end @prepend_empty_softline
)

; Indent and add softlines in multiline application expressions, such as
; let _ =
;   long_function
;     long_argument_1
;     long_argument_2
;     long_argument_3
;     long_argument_4
(application_expression
  .
  (_) @append_indent_start
  (_) @append_indent_end
  .
)
(application_expression
  (_) @append_spaced_softline
  .
  (_)
)

; Indent and allow softlines in multiline function definitions, such as
; let long_function
;     (long_argument_1: int)
;     (long_argument_2: int)
;     (long_argument_3: int)
;     (long_argument_4: int)
;     : int
;   =
;   42
(let_binding
  .
  (_) @append_indent_start @append_indent_start
  "=" @prepend_indent_end
  (_) @append_indent_end
  .
)
(let_binding
  .
  (_) @begin_scope
  "=" @end_scope
  (#scope_id! "let_binding_before_equal")
)
(let_binding
  (parameter) @prepend_spaced_scoped_softline
  (#scope_id! "let_binding_before_equal")
)
(let_binding
  ":"? @prepend_spaced_scoped_softline
  "=" @prepend_spaced_scoped_softline
  (#scope_id! "let_binding_before_equal")
)

; Indent and allow softlines in anonymous function definitions, such as
; fun
;   (long_argument_1: int)
;   (long_argument_2: int)
;   (long_argument_3: int)
;   (long_argument_4: int) ->
;   ()
(fun_expression
  .
  "fun" @append_indent_start @append_indent_start
  "->" @prepend_indent_end
  (_) @append_indent_end
  .
)
(fun_expression
  .
  "fun" @begin_scope
  "->" @end_scope
  (#scope_id! "fun_expr_before_arrow")
)
(fun_expression
  (parameter) @prepend_spaced_scoped_softline
  (#scope_id! "fun_expr_before_arrow")
)
(fun_expression
  ":"? @prepend_spaced_scoped_softline
  "->" @prepend_spaced_scoped_softline
  (#scope_id! "fun_expr_before_arrow")
)

; Indent and allow softlines in tuples, such as
; let _ =
;   (
;     long_value_1,
;     long_value_2,
;     long_value_3
;   )
(parenthesized_expression
  .
  "(" @append_empty_softline @append_indent_start
  ")" @prepend_indent_end @prepend_empty_softline
  .
)
; Parenthesis are optional when using tuples, so scopes must be tied
; to the \`product_expression\` inside.
; Product expressions are nested grammar elements, which means that the syntax tree of
; 1, 2, 3
; is
; {Node product_expression}
;   {Node product_expression}
;     {Node number}
;     {Node ,}
;     {Node number}
;   {Node ,}
;   {Node number}
; We only want to define a scope around the outermost \`product_expression\`,
; which is the one that *isn't* followed by a comma.
(
  (product_expression) @begin_scope @end_scope
  .
  ","? @do_nothing
  (#scope_id! "tuple")
)
(product_expression
  "," @append_spaced_scoped_softline
  (#scope_id! "tuple")
)

; Allow softlines in function types, such as
; type t =
;   a ->
;   (b -> c) ->
;   d ->
;   e
; Function types are nested grammar elements, which means that the syntax tree of
; a -> b -> c
; is
; {Node function_type}
;   {Node type_constructor_path}
;     {Node type_constructor}
;   {Node ->}
;   {Node function_type}
;     {Node type_constructor_path}
;       {Node type_constructor}
;     {Node ->}
;     {Node type_constructor_path}
;       {Node type_constructor}
; We only want to define a scope around the outermost \`function_type\` node,
; which is the one that *isn't* preceded by an arrow.
(
  "->"? @do_nothing
  .
  (function_type) @begin_scope @end_scope
  (#scope_id! "function_type")
)
(function_type
  "->" @append_spaced_scoped_softline
  (#scope_id! "function_type")
)

; Allow softlines in infix expressions, such as
; let b =
;   foo
;   || bar
;   || baz

; As above, infix expressions are nested grammar elements, so we must identify the
; top-level one: it is the one that is not preceded by an infix operator.
; We only consider the common logic operators, as not to mess with arithmetic expressions
(
  (infix_operator
    [
      "||"
      "&&"
    ]
  )? @do_nothing
  .
  (infix_expression) @begin_scope @end_scope
  (#scope_id! "infix_expression")
)
(infix_expression
  (infix_operator
    [
      "||"
      "&&"
    ]
  ) @prepend_spaced_scoped_softline
  (#scope_id! "infix_expression")
)

; Allow softlines in sequences and ppx sequences, such as
; let b =
;   foo;
;   bar;
;   baz
; As above, sequences are nested grammar elements, so we must identify the
; top-level one: it is the one that is not preceded by a ";" (or ";%foo" for ppx sequences).
(
  ";"? @do_nothing
  .
  (sequence_expression
    .
    _
    .
    ";"
    .
    "%"? @do_nothing
  ) @begin_scope @end_scope
  (#scope_id! "sequence_expression")
)
(sequence_expression
  ";" @append_spaced_scoped_softline
  (#scope_id! "sequence_expression")
)

(
  ";"?
  .
  "%"? @do_nothing
  .
  (attribute_id)?
  .
  (sequence_expression
    .
    _
    .
    ";"
    .
    "%"
  ) @begin_scope @end_scope
  (#scope_id! "ppx_sequence_expression")
)
(sequence_expression
  ";"
  .
  "%"
  .
  (attribute_id) @append_spaced_scoped_softline
  (#scope_id! "ppx_sequence_expression")
)

; Indent and add softlines in lists and arrays, such as
; let _ =
;   [
;     long_value_1;
;     long_value_2;
;     long_value_3;
;   ]
(list_expression
  .
  "[" @append_indent_start @append_empty_softline
  "]" @prepend_indent_end @prepend_empty_softline
  .
)

(list_pattern
  .
  "[" @append_indent_start @append_empty_softline
  "]" @prepend_indent_end @prepend_empty_softline
  .
)

(array_expression
  .
  "[|" @append_indent_start @append_empty_softline
  "|]" @prepend_indent_end @prepend_empty_softline
  .
)

(array_pattern
  .
  "[|" @append_indent_start @append_empty_softline
  "|]" @prepend_indent_end @prepend_empty_softline
  .
)

; Allow softlines and indentation in functor definitions with many arguments, such as
; module Lift
;   (Credit: module type of CreditSignature)
;   (Dance: module type of DanceSignature)
;   (Tune: module type of TuneSignature)
;   (Version: module type of VersionSignature)
; = struct
;   let foo = x
; end
(module_binding
  (module_name) @append_indent_start @begin_scope
  "=" @prepend_empty_scoped_softline @prepend_indent_end @end_scope
  (#scope_id! "module_binding_before_equal")
)
; if a module binding has no equal sign and isn't just a signature, everything enters the scope
(module_binding
  (#scope_id! "module_binding_before_equal")
  (module_name) @append_indent_start @begin_scope
  "="? @do_nothing
  (signature)? @do_nothing
) @append_indent_end @end_scope
(module_binding
  (module_name) @append_empty_scoped_softline
  (module_parameter) @prepend_spaced_scoped_softline
  (#scope_id! "module_binding_before_equal")
)

; Try block formatting
; A soft linebreak after the "try" (potentially "try%ppx") and one after the "with".
(try_expression
  "try" @append_spaced_softline @append_indent_start
  .
  "%"* @do_nothing
)
(try_expression
  "try"
  .
  "%"
  .
  (attribute_id) @append_spaced_softline @append_indent_start
)
(try_expression
  "with" @prepend_indent_end @prepend_spaced_softline @append_indent_start
  (_) @append_indent_end
  .
)

; Formatting set expressions
(set_expression
  "<-" @append_spaced_softline @append_indent_start
) @append_indent_end

; Input softlines before and after all comments. This means that the input
; decides if a comment should have line breaks before or after. But don't put a
; softline directly in front of commas or semicolons.

(comment) @prepend_input_softline

(
  (comment) @append_input_softline
  .
  [ "," ";" ]* @do_nothing
)
`,
  },
};

export default languages;
